{
  "node_modules/@hyperoracle/zkgraph-lib/common/constants.ts": "export const U256_LEN = 32;\nexport const MAX_EVENTS = 20;\nexport const MAX_BLOCK_LENGTH = 3;\n",
  "node_modules/@hyperoracle/zkgraph-lib/common/type.ts": "// zkWASM friendly and Subgraph equivalent AssemblyScript API for zkGraph:\n// (https://thegraph.com/docs/en/developing/assemblyscript-api/)\n// Reference Implementation:\n// (https://github.com/graphprotocol/graph-tooling/tree/main/packages/ts)\n\n// class BigInt\nexport * from \"./types/bigInt\";\n// class ByteArray, Bytes, Address\nexport { ByteArray, Bytes, Address } from \"./types/bytes\";\n\n// used in asc to rm env.abort\nfunction abort(a: usize, b: usize, c: u32, d: u32): void {}\n",
  "node_modules/@hyperoracle/zkgraph-lib/common/types/bigInt.ts": "import * as typeConversion from \"../../utils/conversion\";\nimport { Bytes } from \"./bytes\";\n\n// Reference Implementation: as-bigint ^0.5.3\n// (https://github.com/polywrap/as-bigint)\n/** An arbitrary size integer represented as an array of UInt32Array. */\nexport class BigInt {\n  private d: Uint32Array; // digits\n  private n: i32 = 0; // digits used\n  private isNeg: boolean; // sign\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 6 lines of wat.\n   */\n  get isNegative(): boolean {\n    return this.isNeg;\n  }\n  private get digits(): Uint32Array {\n    return this.d;\n  }\n\n  // private static readonly q: i32 = 2;\n  private static readonly p: i32 = 28; // bits used in digit\n  // private static readonly b: u32 = BigInt.q ** BigInt.p; // digit basis\n  private static readonly actualBits: i32 = 32; // bits available in type (single precision)\n  // private static readonly doubleActualBits: i32 = 64 // 2 * BigIntMP.actualBits -> \"double precision\" actual bits\n  private static readonly maxComba: i32 = 256; // 2^(doubleActualBits - 2 * p) = 2^8 = 256\n\n  private static readonly digitMask: u32 = <u32>((1 << BigInt.p) - 1); // mask p least significant bits\n\n  private static readonly precision: i32 = 5; // base array size fits 140 bit integers\n\n  // private static readonly maxBits: i32 = I32.MAX_VALUE;\n  // private static readonly maxN: i32 = BigInt.maxBits / BigInt.p;\n\n  // CONSTRUCTORS //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  private constructor(\n    size: i32 = BigInt.precision,\n    isNegative: boolean = false,\n  ) {\n    this.d = new Uint32Array(size);\n    this.isNeg = isNegative;\n  }\n\n  // generic constructor based on https://github.com/ttulka/as-big/blob/main/assembly/Big.ts#L84\n  /**\n   * Returns a new {BigInt} instance from generic type {T}.\n   *\n   * @param  val the number as {BigInt}, {string}, or {number}\n   * @return BigInt the new {BigInt} instance\n   */\n  static from<T>(val: T): BigInt {\n    if (val instanceof BigInt) return val;\n    // @ts-ignore\n    if (val instanceof string) return BigInt.fromString(val);\n    if (val instanceof i8) return BigInt.fromI16(<i16>val);\n    // @ts-ignore\n    if (val instanceof u8) return BigInt.fromU16(<u16>val);\n    // @ts-ignore\n    if (val instanceof i16) return BigInt.fromI16(val);\n    // @ts-ignore\n    if (val instanceof u16) return BigInt.fromU16(val);\n    // @ts-ignore\n    if (val instanceof i32) return BigInt.fromI32(val);\n    // @ts-ignore\n    if (val instanceof u32) return BigInt.fromU32(val);\n    // @ts-ignore\n    if (val instanceof i64) return BigInt.fromI64(val);\n    // @ts-ignore\n    if (val instanceof u64) return BigInt.fromU64(val);\n    // Uint8Array, Bytes, ByteArray\n    // @ts-ignore\n    if (val instanceof Uint8Array) return BigInt.fromBytes(val);\n\n    throw new TypeError(\"Unsupported generic type \" + nameof<T>(val));\n  }\n\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 2096 line of wat.\n   */\n  static fromString(bigInteger: string, radix: i32 = 10): BigInt {\n    if (radix < 2 || radix > 16) {\n      throw new RangeError(\"BigInt only reads strings of radix 2 through 16\");\n    }\n    let i: i32 = 0;\n    let isNegative: boolean = false;\n    if (bigInteger.charAt(0) == \"-\") {\n      i++;\n      isNegative = true;\n    }\n    if (\n      (radix == 16 || radix == 10) &&\n      bigInteger.charAt(i) == \"0\" &&\n      bigInteger.charAt(i + 1) == \"x\"\n    ) {\n      i += 2;\n      radix = 16;\n    }\n    let res: BigInt = BigInt.fromU16(0);\n    const radixU: u16 = <u16>radix;\n    for (; i < bigInteger.length; i++) {\n      const code: i32 = bigInteger.charCodeAt(i);\n      let val: u16;\n      if (code >= 48 && code <= 57) {\n        val = <u16>(code - 48);\n      } else if (code >= 65 && code <= 70) {\n        val = <u16>(code - 55);\n      } else if (code >= 97 && code <= 102) {\n        val = <u16>(code - 87);\n      } else {\n        throw new RangeError(\n          \"Character \" +\n            bigInteger.charAt(i) +\n            \" is not supported for radix \" +\n            radix.toString(),\n        );\n      }\n      res = res.inplaceMulInt(radixU).plus(BigInt.fromU16(val));\n    }\n    res.isNeg = isNegative;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  static fromU16(val: u16): BigInt {\n    const res = new BigInt(BigInt.precision, false);\n    res.d[0] = (<u32>val) & BigInt.digitMask;\n    res.n = res.d[0] != 0 ? 1 : 0;\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 93 lines of wat.\n   */\n  static fromU32(val: u32): BigInt {\n    const res = new BigInt(BigInt.precision, false);\n    let i = 0;\n    while (val != 0) {\n      res.d[i++] = val & BigInt.digitMask;\n      val >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 99 lines of wat.\n   */\n  static fromU64(val: u64): BigInt {\n    const res = new BigInt(BigInt.precision, false);\n    let i = 0;\n    while (val != 0) {\n      res.d[i++] = (<u32>val) & BigInt.digitMask;\n      val >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  static fromI16(val: i16): BigInt {\n    const isNeg: boolean = val < 0;\n    const res = new BigInt(BigInt.precision, isNeg);\n    const unsignedDigit: u16 = <u16>(isNeg ? -1 * val : val);\n    res.d[0] = (<u32>unsignedDigit) & BigInt.digitMask;\n    res.n = res.d[0] != 0 ? 1 : 0;\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 93 lines of wat.\n   */\n  static fromI32(val: i32): BigInt {\n    const isNeg: boolean = val < 0;\n    const res = new BigInt(BigInt.precision, isNeg);\n    let unsignedDigit: u32 = <u32>(isNeg ? -1 * val : val);\n    let i = 0;\n    while (unsignedDigit != 0) {\n      res.d[i++] = unsignedDigit & BigInt.digitMask;\n      unsignedDigit >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 99 lines of wat.\n   */\n  static fromI64(val: i64): BigInt {\n    const isNeg: boolean = val < 0;\n    const res = new BigInt(BigInt.precision, isNeg);\n    let unsignedDigit: u64 = <u64>(isNeg ? -1 * val : val);\n    let i = 0;\n    while (unsignedDigit != 0) {\n      res.d[i++] = (<u32>unsignedDigit) & BigInt.digitMask;\n      unsignedDigit >>= BigInt.p;\n    }\n    res.n = i;\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // O(N)\n  private static fromDigits(\n    digits: Uint32Array,\n    isNegative: boolean = false,\n    n: i32 = digits.length,\n    minSize: i32 = digits.length,\n  ): BigInt {\n    let size = minSize;\n    if (size < digits.length) {\n      size = digits.length;\n    }\n    const extra = size % BigInt.precision;\n    if (extra != 0) {\n      size += BigInt.precision - extra;\n    }\n    const res: BigInt = new BigInt(size, isNegative);\n    for (let i = 0; i < digits.length; i++) {\n      res.d[i] = digits[i];\n    }\n    res.n = n;\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 568 lines of wat.\n   */\n  static fromBytesLittleEndian(bytes: Uint8Array, isNegative: boolean = false): BigInt {\n    let digits = typeConversion.uint8ArrayToUint32Array(bytes);\n    return BigInt.fromDigits(digits, isNegative);\n  }\n\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 744 line of wat.\n   */\n  static fromBytes(\n    bytes: Uint8Array,\n    isNegative: boolean = false,\n  ): BigInt {\n    let digits = typeConversion.uint8ArrayToUint32Array(bytes, false);\n    return BigInt.fromDigits(digits, isNegative);\n  }\n\n  // O(N)\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 113 lines of wat.\n   */\n  copy(): BigInt {\n    return BigInt.fromDigits(this.d, this.isNeg, this.n);\n  }\n\n  // O(N)\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 123 lines of wat.\n   */\n  neg(): BigInt {\n    return BigInt.fromDigits(this.d, this.n > 0 && !this.isNeg, this.n);\n  }\n\n  // O(N)\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 110 lines of wat.\n   */\n  abs(): BigInt {\n    return BigInt.fromDigits(this.d, false, this.n);\n  }\n\n  private static getEmptyResultContainer(\n    minSize: i32,\n    isNegative: boolean,\n    n: i32,\n  ): BigInt {\n    const size: i32 = minSize + BigInt.precision - (minSize % BigInt.precision);\n    const res: BigInt = new BigInt(size, isNegative);\n    res.n = n;\n    return res;\n  }\n\n  // MAINTENANCE FUNCTIONS /////////////////////////////////////////////////////////////////////////////////////////////\n\n  private trimLeadingZeros(): void {\n    while (this.n > 0 && this.d[this.n - 1] == 0) {\n      this.n--;\n    }\n    if (this.n == 0) {\n      this.isNeg = false;\n    }\n  }\n\n  private resize(max: i32): void {\n    const temp: Uint32Array = new Uint32Array(max);\n    for (let i = 0; i < this.n; i++) {\n      temp[i] = this.d[i];\n    }\n    this.d = temp;\n  }\n\n  private grow(size: i32): void {\n    if (this.d.length >= size) return;\n    this.resize(size + 2 * BigInt.precision - (size % BigInt.precision));\n  }\n\n  // OUTPUT /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1177 lines of wat.\n   */\n  toString(radix: i32 = 10): string {\n    if (radix < 2 || radix > 16) {\n      throw new RangeError(\"BigInt only prints strings in radix 2 through 16\");\n    }\n    if (this.n == 0) return \"0\";\n    let res: string = this.isNeg ? \"-\" : \"\";\n    let t: BigInt = this.abs();\n    const zero: BigInt = BigInt.fromU16(0);\n    const codes: i32[] = [];\n    const radixU: u32 = <u32>radix;\n    while (t.notEqual(zero)) {\n      const d: i32 = <i32>t.modInt(radixU);\n      t = t.inplaceDivInt(radixU);\n      if (d < 10) {\n        codes.push(d + 48);\n      } else {\n        codes.push(d + 87);\n      }\n    }\n    codes.reverse();\n    res += String.fromCharCodes(codes);\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1177 lines of wat.\n   */\n  toHex(): string {\n    return this.toString(16);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1192 lines of wat.\n   */\n  toHexString(prefix: string = \"\"): string {\n    if (prefix !== \"\") {\n      return prefix + this.toHex();\n    }\n    return this.toHex();\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1735 lines of wat.\n   */\n  toI32(): i32 {\n    if (this.n <= 1) {\n      return this.n == 0 ? <i32>0 : <i32>this.d[0] * (this.isNeg ? -1 : 1);\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 32) {\n      throw new Error(\n        `Integer overflow: cannot output i32 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    const biString: string = this.toString();\n    const result: i32 = I32.parseInt(biString);\n    if (bitCount == 32 && result.toString() != biString) {\n      throw new Error(\"Signed integer overflow\");\n    }\n    return result;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 2166 lines of wat.\n   */\n  toI64(): i64 {\n    if (this.n <= 1) {\n      return this.n == 0 ? <i64>0 : <i64>this.d[0] * (this.isNeg ? -1 : 1);\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 64) {\n      throw new Error(\n        `Integer overflow: cannot output i64 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    const biString: string = this.toString();\n    const result: i64 = I64.parseInt(biString);\n    if (bitCount == 64 && result.toString() != biString) {\n      throw new Error(\"Signed integer overflow\");\n    }\n    return result;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1710 lines of wat.\n   */\n  toU32(): u32 {\n    if (this.isNeg) {\n      throw new Error(\"Cannot cast negative integer to u32\");\n    }\n    if (this.n <= 1) {\n      return this.n == 0 ? <u32>0 : <u32>this.d[0];\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 32) {\n      throw new Error(\n        `Integer overflow: cannot output u32 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    return U32.parseInt(this.toString());\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1882 lines of wat.\n   */\n  toU64(): u64 {\n    if (this.isNeg) {\n      throw new Error(\"Cannot cast negative integer to u64\");\n    }\n    if (this.n <= 1) {\n      return this.n == 0 ? <u64>0 : <u64>this.d[0];\n    }\n    const bitCount: i32 = this.countBits();\n    if (bitCount > 64) {\n      throw new Error(\n        `Integer overflow: cannot output u64 from an integer that uses ${bitCount} bits`,\n      );\n    }\n    return U64.parseInt(this.toString());\n  }\n\n  // COMPARISON OPERATORS //////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  equals<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) == 0;\n  }\n\n  eq<T>(other: T): boolean {\n    return this.equals(other);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  notEqual<T>(other: T): boolean {\n    return !this.equals(BigInt.from(other));\n  }\n\n  ne<T>(other: T): boolean {\n    return this.notEqual(other);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  lt<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) < 0;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  le<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) <= 0;\n  }\n\n  lte<T>(other: T): boolean {\n    return this.le(other);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  gt<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) > 0;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  ge<T>(other: T): boolean {\n    return this.compareTo(BigInt.from(other)) >= 0;\n  }\n\n  gte<T>(other: T): boolean {\n    return this.ge(other);\n  }\n\n  private compareTo(other: BigInt): i32 {\n    // opposite signs\n    if (this.isNeg && !other.isNeg) {\n      return -1;\n    } else if (!this.isNeg && other.isNeg) {\n      return 1;\n    } else if (this.isNeg) {\n      return other.magCompareTo(this);\n    } else {\n      return this.magCompareTo(other);\n    }\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 155 lines of wat.\n   */\n  static compare(a: BigInt, b: BigInt): i32 {\n    return a.compareTo(b);\n  }\n\n  private magCompareTo(other: BigInt): i32 {\n    if (this.n > other.n) return 1;\n    if (this.n < other.n) return -1;\n    for (let i = this.n - 1; i >= 0; i--) {\n      if (this.d[i] != other.d[i]) {\n        if (this.d[i] < other.d[i]) return -1;\n        else return 1;\n      }\n    }\n    return 0;\n  }\n\n  // CORE MATH OPERATIONS //////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * signed addition\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 816 lines of wat.\n   */\n  plus<T>(other: T): BigInt {\n    const addend: BigInt = BigInt.from(other);\n    if (this.isNeg == addend.isNeg) {\n      return this._add(addend, this.isNeg);\n    } else if (this.magCompareTo(addend) < 0) {\n      return addend._sub(this, addend.isNeg);\n    } else {\n      return this._sub(addend, this.isNeg);\n    }\n  }\n\n  add<T>(other: T): BigInt {\n    return this.plus(other);\n  }\n\n  /**\n   * signed subtraction\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 819 lines of wat.\n   */\n  minus<T>(other: T): BigInt {\n    const subtrahend: BigInt = BigInt.from(other);\n    if (this.isNeg != subtrahend.isNeg) {\n      return this._add(subtrahend, this.isNeg);\n    } else if (this.magCompareTo(subtrahend) >= 0) {\n      return this._sub(subtrahend, this.isNeg);\n    } else {\n      return subtrahend._sub(this, !this.isNeg);\n    }\n  }\n\n  sub<T>(other: T): BigInt {\n    return this.minus(other);\n  }\n\n  // unsigned addition\n  private _add(other: BigInt, resultIsNegative: boolean): BigInt {\n    // determine which summand is larger\n    let min: i32;\n    let max: i32;\n    let x: BigInt;\n    if (this.n > other.n) {\n      min = other.n;\n      max = this.n;\n      x = this;\n    } else {\n      min = this.n;\n      max = other.n;\n      x = other;\n    }\n    // initialize result\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      max + 1,\n      resultIsNegative,\n      max,\n    );\n    // add\n    let carry: u32 = 0;\n    let i: i32 = 0;\n    for (; i < min; i++) {\n      res.d[i] = this.d[i] + other.d[i] + carry;\n      carry = res.d[i] >> BigInt.p;\n      res.d[i] &= BigInt.digitMask;\n    }\n    if (min != max) {\n      for (; i < max; i++) {\n        res.d[i] = x.d[i] + carry;\n        carry = res.d[i] >> BigInt.p;\n        res.d[i] &= BigInt.digitMask;\n      }\n    }\n    if (carry > 0) {\n      res.d[max] = carry;\n      res.n++;\n    }\n    return res;\n  }\n\n  // unsigned subtraction\n  private _sub(other: BigInt, resultIsNegative: boolean): BigInt {\n    const min: i32 = other.n;\n    const max: i32 = this.n;\n    // initialize result\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      max,\n      resultIsNegative,\n      max,\n    );\n    // subtract\n    let carry: u32 = 0;\n    let i: i32 = 0;\n    for (; i < min; i++) {\n      res.d[i] = this.d[i] - other.d[i] - carry;\n      carry = res.d[i] >> (BigInt.actualBits - 1);\n      res.d[i] &= BigInt.digitMask;\n    }\n    if (min < max) {\n      for (; i < max; i++) {\n        res.d[i] = this.d[i] - carry;\n        carry = res.d[i] >> (BigInt.actualBits - 1);\n        res.d[i] &= BigInt.digitMask;\n      }\n    }\n    // trim and return\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // unsigned addition of 1\n  private _addOne(resultIsNegative: boolean): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      this.n + 1,\n      resultIsNegative,\n      this.n,\n    );\n    let carry = 1;\n    for (let i = 0; i < this.n; i++) {\n      res.d[i] = this.d[i] + carry;\n      carry = res.d[i] >> BigInt.p;\n      res.d[i] &= BigInt.digitMask;\n    }\n    if (carry > 0) {\n      res.d[this.n] = carry;\n      res.n++;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // unsigned subtraction of 1\n  private _subOne(resultIsNegative: boolean): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      this.n,\n      resultIsNegative,\n      this.n,\n    );\n    let carry = 1;\n    for (let i = 0; i < this.n; i++) {\n      res.d[i] = this.d[i] - carry;\n      carry = res.d[i] >> (BigInt.actualBits - 1);\n      res.d[i] &= BigInt.digitMask;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // efficient multiply by 2\n  private mul2(): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      this.n + 1,\n      this.isNeg,\n      this.n,\n    );\n    let r: u32 = 0;\n    for (let i = 0; i < this.n; i++) {\n      const rr: u32 = this.d[i] >> (BigInt.p - 1);\n      res.d[i] = ((this.d[i] << 1) | r) & BigInt.digitMask;\n      r = rr;\n    }\n    if (r != 0) {\n      res.d[res.n++] = 1;\n    }\n    return res;\n  }\n\n  // efficient div by 2\n  private div2(): BigInt {\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      this.n,\n      this.isNeg,\n      this.n,\n    );\n    let r: u32 = 0;\n    for (let i = this.n - 1; i >= 0; i--) {\n      const rr: u32 = this.d[i] % 2;\n      res.d[i] = (this.d[i] >> 1) | (r << (BigInt.p - 1));\n      r = rr;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // multiples BigInt by power of basis\n  // *** mutates BigInt ***\n  private mulBasisPow(b: i32): void {\n    if (b <= 0) return;\n    this.grow(this.n + b);\n    this.n += b;\n    let i: i32 = this.n - 1;\n    let j: i32 = this.n - 1 - b;\n    for (; i >= b; i--, j--) {\n      this.d[i] = this.d[j];\n    }\n    for (; i >= 0; i--) {\n      this.d[i] = 0;\n    }\n  }\n\n  // divides BigInt by power of basis\n  // *** mutates BigInt ***\n  private divBasisPow(b: i32): void {\n    if (b <= 0) return;\n    // integer division with denominator > numerator = 0\n    if (this.n <= b) {\n      this.n = 0;\n      this.trimLeadingZeros();\n      return;\n    }\n    // division\n    let i: i32 = 0;\n    let j: i32 = b;\n    for (; i < this.n - b; i++, j++) {\n      this.d[i] = this.d[j];\n    }\n    for (; i < this.n; i++) {\n      this.d[i] = 0;\n    }\n    this.n -= b;\n  }\n\n  // multiply by power of 2\n  // O(2N)\n  private mulPowTwo(k: i32): BigInt {\n    if (k <= 0) {\n      return this.copy();\n    }\n    const minSize: i32 = this.n + k / BigInt.p + 1;\n    const res = BigInt.fromDigits(this.d, this.isNeg, this.n, minSize);\n    // shift by entire digits\n    if (k >= BigInt.p) {\n      res.mulBasisPow(k / BigInt.p);\n    }\n    // shift by k % p bits\n    const remK: i32 = k % BigInt.p;\n    if (remK != 0) {\n      const mask: u32 = <u32>((1 << remK) - 1);\n      const shift: i32 = BigInt.p - remK;\n      let r: u32 = 0;\n      for (let i = 0; i < res.n; i++) {\n        const rr: u32 = (res.d[i] >> shift) & mask;\n        res.d[i] = ((res.d[i] << remK) | r) & BigInt.digitMask;\n        r = rr;\n      }\n      if (r != 0) {\n        res.d[res.n++] = r;\n      }\n    }\n    return res;\n  }\n\n  // divide by power of 2\n  private divPowTwo(k: i32): BigInt {\n    const res = this.copy();\n    if (k <= 0) {\n      return res;\n    }\n    if (k >= BigInt.p) {\n      res.divBasisPow(k / BigInt.p);\n    }\n    const remK: i32 = k % BigInt.p;\n    if (remK != 0) {\n      const mask: u32 = <u32>((1 << remK) - 1);\n      const shift: i32 = BigInt.p - remK;\n      let r: u32 = 0;\n      for (let i = res.n - 1; i >= 0; i--) {\n        const rr: u32 = res.d[i] & mask;\n        res.d[i] = (res.d[i] >> remK) | (r << shift);\n        r = rr;\n      }\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // remainder of division by power of 2\n  private modPowTwo(k: i32): BigInt {\n    if (k == 0) {\n      return BigInt.fromU16(<u16>0);\n    }\n    const res = this.copy();\n    // if 2^k > BigInt, then BigInt % 2^k == BigInt\n    if (k > this.n * BigInt.p) {\n      return res;\n    }\n    // zero out unused digits (any digit greater than 2^b)\n    const kDivP: i32 = k / BigInt.p;\n    let i: i32 = kDivP + (k % BigInt.p) == 0 ? 0 : 1; // ceil of k / p\n    for (; i < res.n; i++) {\n      res.d[i] = 0;\n    }\n    // mod the remaining leading digit (which includes 2^b) using bitmask\n    // remK = k % BigIntMP.p\n    res.d[kDivP] &= ((<u32>1) << k % BigInt.p) - <u32>1;\n    // trim and return\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  /**\n   * Left bit shift\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 227 lines of wat.\n   */\n  leftShift(k: i32): BigInt {\n    if (k == 0) return this.copy();\n    if (k < 0) return this.rightShiftByAbsolute(k);\n    return this.leftShiftByAbsolute(k);\n  }\n\n  /**\n   * Signed right bit shift\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 591 lines of wat.\n   */\n  rightShift(k: i32): BigInt {\n    if (k == 0) return this.copy();\n    if (k < 0) return this.leftShiftByAbsolute(k);\n    return this.rightShiftByAbsolute(k);\n  }\n\n  private leftShiftByAbsolute(k: i32): BigInt {\n    return this.mulPowTwo(k >>> 0);\n  }\n\n  private rightShiftByAbsolute(k: i32): BigInt {\n    const shift: i32 = k >>> 0;\n    // shift by max if result would equal 0\n    if (this.n - shift / BigInt.p <= 0) {\n      return BigInt.rightShiftByMaximum(this.isNeg);\n    }\n    // arithmetic shift\n    const res: BigInt = this.divPowTwo(shift);\n    // for negative numbers, round down if a bit would be shifted out\n    // Since the result is negative, rounding down means adding one to its absolute value. This cannot overflow.\n    if (this.rightShiftMustRoundDown(shift)) {\n      return res._addOne(true);\n    }\n    return res;\n  }\n\n  // For negative numbers, round down if any bit was shifted out (so that\n  // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen\n  // and whether it can cause overflow into a new digit. If we allocate the\n  // result large enough up front, it avoids having to do grow it later.\n  private rightShiftMustRoundDown(k: i32): boolean {\n    if (this.isNeg) {\n      const digitShift: i32 = k / BigInt.p;\n      const remK: i32 = k % BigInt.p;\n      const mask: u32 = <u32>((1 << remK) - 1);\n      if ((this.d[digitShift] & mask) != 0) {\n        return true;\n      } else {\n        for (let i = 0; i < digitShift; i++) {\n          if (this.d[i] != 0) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private static rightShiftByMaximum(isNeg: boolean): BigInt {\n    if (isNeg) {\n      return BigInt.NEG_ONE;\n    }\n    return BigInt.zero();\n  }\n\n  // MULTIPLICATION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Chooses best multiplication algorithm for situation and handles sign\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 498 lines of wat.\n   */\n  times<T>(other: T): BigInt {\n    const multiplier: BigInt = BigInt.from(other);\n    let res: BigInt;\n    const digitsNeeded: i32 = this.n + multiplier.n + 1;\n    const minN: i32 = this.n <= multiplier.n ? this.n : multiplier.n;\n    if (digitsNeeded < BigInt.maxComba && minN < BigInt.maxComba) {\n      res = this._mulComba(multiplier, digitsNeeded);\n    } else {\n      res = this._mulPartial(multiplier, digitsNeeded);\n    }\n    res.isNeg = this.isNeg != multiplier.isNeg && res.n > 0;\n    return res;\n  }\n\n  mul<T>(other: T): BigInt {\n    return this.times(other);\n  }\n\n  // unsigned multiplication that returns at most maxDigits\n  private _mulPartial(other: BigInt, maxDigits: i32): BigInt {\n    // const min: i32 = this.n <= other.n ? this.n : other.n;\n    // optimization -> use Comba multiplication if possible\n    // if (maxDigits < BigInt.maxComba && min < BigInt.maxComba) {\n    //   return this._mulComba(other, maxDigits);\n    // }\n    const res = BigInt.getEmptyResultContainer(maxDigits, false, maxDigits);\n    // multiply using standard O(N^2) method taught in schools\n    for (let i = 0; i < this.n; i++) {\n      let r: u32 = 0;\n      const digsSubI: i32 = maxDigits - i;\n      const limitedN: i32 = other.n < digsSubI ? other.n : digsSubI;\n      for (let j = 0; j < limitedN; j++) {\n        const rr: u64 = <u64>res.d[i + j] + <u64>this.d[i] * other.d[j] + r;\n        res.d[i + j] = <u32>(rr & (<u64>BigInt.digitMask));\n        r = <u32>(rr >> BigInt.p);\n      }\n      if (i + limitedN < maxDigits) {\n        res.d[i + limitedN] = r;\n      }\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // fast unsigned multiplication using Comba method\n  private _mulComba(other: BigInt, maxDigits: i32): BigInt {\n    const totalN = this.n + other.n;\n    const outerN: i32 = maxDigits < totalN ? maxDigits : totalN; // number of output digits to produce\n    const res = BigInt.getEmptyResultContainer(outerN, false, outerN);\n    let w: u64 = 0;\n    // multiply, ignoring carries\n    for (let i = 0; i < outerN; i++) {\n      // calculate tY and tX, offsets into the multiplicands\n      const maxJ: i32 = other.n - 1;\n      const tY: i32 = maxJ < i ? maxJ : i;\n      const tX: i32 = i - tY;\n      // calculate innerN, the number of times inner loop will iterate\n      const distFromEnd: i32 = this.n - tX;\n      const currentN: i32 = tY + 1;\n      const innerN: i32 = distFromEnd < currentN ? distFromEnd : currentN;\n      for (let j = 0; j < innerN; j++) {\n        w += <u64>this.d[tX + j] * other.d[tY - j];\n      }\n      res.d[i] = (<u32>w) & BigInt.digitMask;\n      w = w >> BigInt.p;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  // EXPONENTIATION ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1308 lines of wat.\n   */\n  pow(k: i32): BigInt {\n    if (k < 0) {\n      throw new RangeError(\"BigInt does not support negative exponentiation\");\n    }\n    let temp: BigInt = this.copy();\n    let res: BigInt = BigInt.ONE;\n    while (k > 0) {\n      /* if the bit is set multiply */\n      if ((k & 1) != 0) res = res.times(temp);\n      /* square */\n      if (k > 1) temp = temp.square();\n      /* shift to next bit */\n      k >>= 1;\n    }\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 672 lines of wat.\n   */\n  square(): BigInt {\n    const digitsNeeded: i32 = this.n + this.n + 1;\n    if (digitsNeeded < BigInt.maxComba) {\n      return this._squareComba();\n    } else {\n      return this._baseSquare();\n    }\n  }\n\n  private _baseSquare(): BigInt {\n    const size: i32 = this.n + this.n + 1;\n    const res = BigInt.getEmptyResultContainer(size, false, size);\n    for (let i = 0; i < size; i++) {\n      let j: i32;\n      // first calculate the digit at 2*i and the double precision result\n      let r: u64 = <u64>this.d[i] * this.d[i] + res.d[i + i];\n      // store lower part in result\n      res.d[i + i] = <u32>(r & BigInt.digitMask);\n      // get the carry\n      let u: u32 = <u32>(r >> BigInt.p);\n      for (j = i + 1; j < size; j++) {\n        // first calculate the product\n        r = <u64>this.d[i] * this.d[j];\n        // now calculate the double precision result\n        r = <u64>res.d[i + j] + r + r + u;\n        // store lower part\n        res.d[i + j] = <u32>(r & BigInt.digitMask);\n        // get carry\n        u = <u32>(r >> BigInt.p);\n      }\n      // propagate upwards\n      while (u != 0) {\n        r = <u64>res.d[i + j] + u;\n        res.d[i + j] = <u32>(r & BigInt.digitMask);\n        u = <u32>(r >> BigInt.p);\n        ++j;\n      }\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  private _squareComba(): BigInt {\n    const size: i32 = this.n + this.n;\n    const res = BigInt.getEmptyResultContainer(size, false, size);\n\n    let u: u64 = 0;\n    for (let i = 0; i < size; i++) {\n      /* clear accumulator */\n      let accum: u64 = 0;\n      /* get offsets into the two BigInts */\n      const nSub1: i32 = this.n - 1;\n      const y: i32 = nSub1 < i ? nSub1 : i; // min\n      const x: i32 = i - y;\n      /* this is the number of times the loop will iterate, essentially\n         while (x++ < this.n && y-- >= 0) { ... }\n       */\n      const nSubX: i32 = this.n - x;\n      const yAdd1: i32 = y + 1;\n      let j: i32 = nSubX < yAdd1 ? nSubX : yAdd1; // min\n      /* now for squaring x can never equal y\n       * we halve the distance since they approach at a rate of 2*\n       * and we have to round because odd cases need to be executed\n       */\n      const shiftedDiff: i32 = (y - x + 1) >> 1;\n      j = j < shiftedDiff ? j : shiftedDiff;\n      /* execute loop */\n      for (let k = 0; k < j; k++) {\n        accum += <u64>this.d[x + k] * this.d[y - k];\n      }\n      /* double the inner product and add carry */\n      accum = accum + accum + u;\n      /* even columns have the square term in them */\n      if (((<u32>i) & 1) == 0) {\n        accum += <u64>this.d[i >> 1] * this.d[i >> 1];\n      }\n      /* store it */\n      res.d[i] = (<u32>accum) & BigInt.digitMask;\n      /* make next carry */\n      u = accum >> BigInt.p;\n    }\n    res.trimLeadingZeros();\n    return res;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 3735 lines of wat.\n   */\n  sqrt(): BigInt {\n    if (this.isNeg)\n      throw new RangeError(\"Square root of negative numbers is not supported\");\n    if (this.n == 0) return this.copy();\n\n    // rely on built in sqrt if possible\n    // Disable this optimization due to Unknown opcode 252 error in zkWASM\n    // if (this.le(BigInt.fromU64(<u64>F64.MAX_SAFE_INTEGER))) {\n    //   const fVal: f64 = <f64>this.toU64();\n    //   const fSqrt: f64 = Math.floor(Math.sqrt(fVal));\n    //   return BigInt.fromU64(<u64>fSqrt);\n    // }\n\n    // Rely on just sqrt of U64 if possible\n    if (this.lt(BigInt.fromU64(U64.MAX_VALUE))) {\n      const xU64 = this.toU64();\n      // Note: This will add 1 to xU64 then overflow if condition is set to lte.\n      let zU64 = (xU64 + 1) / 2;\n      let yU64 = xU64;\n      while (zU64 < yU64) {\n        yU64 = zU64;\n        zU64 = (xU64 / zU64 + zU64) / 2;\n      }\n      return BigInt.fromU64(yU64);\n    }\n\n    // Newton Raphson iteration\n    let z: BigInt = this; // eslint-disable-line  @typescript-eslint/no-this-alias\n    let x: BigInt = BigInt.fromU16(1).mulPowTwo(this.countBits() / 2);\n    x = this.div(x).plus(x).div2();\n    while (x < z) {\n      z = x;\n      x = this.div(x).plus(x).div2();\n    }\n\n    return z;\n  }\n\n  // DIVISION //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // handles sign and allows for easy replacement of algorithm in future update\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1925 lines of wat.\n   */\n  div<T>(other: T): BigInt {\n    return this._div(BigInt.from(other));\n  }\n\n  // handles sign and allows for easy replacement of algorithm in future update\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1906 line of wat.\n   */\n  mod<T>(other: T): BigInt {\n    return this._divRemainder(BigInt.from(other));\n  }\n\n  // returns [quotient, remainder]\n  private divMod<T>(other: T): BigInt[] {\n    return this._divMod(BigInt.from(other));\n  }\n\n  private _div(other: BigInt): BigInt {\n    if (other.equals(BigInt.fromU16(0))) {\n      throw new Error(\"Divide by zero\");\n    }\n    const cmp: i32 = this.magCompareTo(other);\n    if (cmp < 0) {\n      return BigInt.fromU16(0);\n    } else if (cmp == 0) {\n      const q = BigInt.fromU16(1);\n      q.isNeg = this.isNeg != other.isNeg;\n      return q;\n    }\n    const res: BigInt[] = this._divCore(other);\n    const q: BigInt = res[0];\n    q.isNeg = this.isNeg != other.isNeg;\n    q.trimLeadingZeros();\n    return q;\n  }\n\n  private _divRemainder(other: BigInt): BigInt {\n    if (other.equals(BigInt.fromU16(0))) {\n      throw new Error(\"Divide zero error\");\n    }\n    const cmp: i32 = this.magCompareTo(other);\n    if (cmp < 0) {\n      return this.copy();\n    } else if (cmp == 0) {\n      return BigInt.fromU16(0);\n    }\n    const res: BigInt[] = this._divCore(other);\n    const r: BigInt = res[1];\n    r.isNeg = this.isNeg;\n    r.trimLeadingZeros();\n    return r;\n  }\n\n  // returns [quotient, remainder]\n  private _divMod(other: BigInt): BigInt[] {\n    if (other.equals(BigInt.fromU16(0))) {\n      throw new Error(\"Divide by zero\");\n    }\n    const cmp: i32 = this.magCompareTo(other);\n    if (cmp < 0) {\n      return [BigInt.fromU16(0), this.copy()];\n    } else if (cmp == 0) {\n      const q = BigInt.fromU16(1);\n      q.isNeg = this.isNeg != other.isNeg;\n      return [q, BigInt.fromU16(0)];\n    }\n    const res: BigInt[] = this._divCore(other);\n    const q: BigInt = res[0];\n    const r: BigInt = res[1];\n    r.isNeg = this.isNeg;\n    r.trimLeadingZeros();\n    q.isNeg = this.isNeg != other.isNeg;\n    q.trimLeadingZeros();\n    return [q, r];\n  }\n\n  private _divCore(other: BigInt): BigInt[] {\n    let q: BigInt = BigInt.fromU16(0);\n    let tempQ = BigInt.fromU16(1);\n    let n: i32 = this.countBits() - other.countBits();\n    let tempA = this.abs();\n    let tempB = other.abs();\n    tempB = tempB.mulPowTwo(n);\n    tempQ = tempQ.mulPowTwo(n);\n    for (; n >= 0; n--) {\n      if (tempB.magCompareTo(tempA) <= 0) {\n        tempA = tempA.minus(tempB);\n        q = q.plus(tempQ);\n      }\n      tempB = tempB.div2();\n      tempQ = tempQ.div2();\n    }\n    return [q, tempA];\n  }\n\n  // divides and rounds to nearest integer\n  private roundedDiv<T>(other: T): BigInt {\n    const divisor: BigInt = BigInt.from(other);\n    if (divisor.equals(BigInt.fromU16(0))) {\n      throw new Error(\"Divide by zero\");\n    }\n    if (this.isZero()) {\n      return BigInt.fromU16(0);\n    }\n    const r: BigInt = divisor.div2();\n    if (this.isNeg != divisor.isNeg) {\n      r.isNeg = !r.isNeg;\n    }\n    return this.plus(r).div(divisor);\n  }\n\n  // SINGLE-DIGIT HELPERS //////////////////////////////////////////////////////////////////////////////////////////////\n\n  private addInt(b: u32): BigInt {\n    return this.plus(BigInt.fromU32(b));\n  }\n\n  private subInt(b: u32): BigInt {\n    return this.minus(BigInt.fromU32(b));\n  }\n\n  private mulInt(b: u32): BigInt {\n    if (b > 268435456) {\n      return this.times(BigInt.fromU32(b));\n    }\n    const res = BigInt.fromDigits(this.d, this.isNeg, this.n, this.n + 1);\n    let r: u32 = 0;\n    for (let i = 0; i < this.n; i++) {\n      const rr: u64 = <u64>this.d[i] * <u64>b + <u64>r;\n      res.d[i] = <u32>(rr & (<u64>BigInt.digitMask));\n      r = <u32>(rr >> BigInt.p);\n    }\n    if (r != 0) {\n      res.d[res.n++] = r;\n    }\n    return res;\n  }\n\n  // MUTATES\n  private inplaceMulInt(b: u32): BigInt {\n    if (b > 268435456) {\n      return this.times(BigInt.fromU32(b));\n    }\n    this.grow(this.n + 1);\n    let r: u32 = 0;\n    for (let i = 0; i < this.n; i++) {\n      const rr: u64 = <u64>this.d[i] * <u64>b + <u64>r;\n      this.d[i] = <u32>(rr & (<u64>BigInt.digitMask));\n      r = <u32>(rr >> BigInt.p);\n    }\n    if (r != 0) {\n      this.d[this.n++] = r;\n    }\n    return this;\n  }\n\n  private divInt(b: u32): BigInt {\n    if (b == 0) throw new Error(\"Divide by zero\");\n    // try optimizations\n    if (b == 1 || this.n == 0) return this.copy();\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) return this.divPowTwo(pow2Bit);\n    // divide\n    const q = BigInt.getEmptyResultContainer(this.n, this.isNeg, this.n);\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n      q.d[i] = val;\n    }\n    q.trimLeadingZeros();\n    return q;\n  }\n\n  // MUTATES\n  private inplaceDivInt(b: u32): BigInt {\n    if (b == 0) throw new Error(\"Divide by zero\");\n    // try optimizations\n    if (b == 1 || this.n == 0) return this;\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) return this.divPowTwo(pow2Bit);\n    // divide\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n      this.d[i] = val;\n    }\n    this.trimLeadingZeros();\n    return this;\n  }\n\n  private modInt(b: u32): u32 {\n    if (b == 0) throw new Error(\"Divide by zero\");\n    // try optimizations\n    if (b == 1 || this.n == 0) {\n      return 0;\n    }\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) {\n      return this.d[0] & (((<u32>1) << pow2Bit) - <u32>1);\n    }\n    // divide\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n    }\n    return <u32>r;\n  }\n\n  // returns [quotient, remainder]\n  private divModInt(b: u32): BigInt[] {\n    if (b == 0) throw new Error(\"Divide by zero\");\n    // try optimizations\n    if (b == 1 || this.n == 0) {\n      return [this.copy(), BigInt.zero()];\n    }\n    const pow2Bit: i32 = BigInt.isPow2(b);\n    if (pow2Bit != 0) {\n      const q: BigInt = this.divPowTwo(pow2Bit);\n      const r: u32 = this.d[0] & (((<u32>1) << pow2Bit) - <u32>1);\n      return [q, BigInt.fromU32(r)];\n    }\n    // divide\n    const q = BigInt.getEmptyResultContainer(this.n, this.isNeg, this.n);\n    let r: u64 = 0;\n    let val: u32;\n    for (let i = this.n - 1; i >= 0; i--) {\n      r = (r << BigInt.p) | (<u64>this.d[i]);\n      if (r >= b) {\n        val = <u32>(r / b);\n        r -= <u64>val * <u64>b;\n      } else {\n        val = 0;\n      }\n      q.d[i] = val;\n    }\n    q.trimLeadingZeros();\n    return [q, BigInt.fromU32(<u32>r)];\n  }\n\n  // divides and rounds to nearest integer\n  private roundedDivInt(b: u32): BigInt {\n    if (b == 0) throw new Error(\"Divide by zero\");\n    if (this.isZero()) {\n      return BigInt.fromU16(0);\n    }\n    const r: BigInt = BigInt.fromU32(b >> 1);\n    if (this.isNeg) {\n      r.isNeg = true;\n    }\n    return this.plus(r).divInt(b);\n  }\n\n  // bit OPERATIONS ////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1925 lines of wat.\n   */\n  @operator.prefix(\"~\")\n  bitNot(): BigInt {\n    if (this.isNeg) {\n      // ~(-x) == ~(~(x-1)) == x-1\n      return this._subOne(false);\n    }\n    // ~x == -x-1 == -(x+1)\n    return this._addOne(true);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 894 lines of wat.\n   */\n  bitAnd<T>(other: T): BigInt {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let a: BigInt = this;\n    let b: BigInt = BigInt.from(other);\n    if (!a.isNeg && !b.isNeg) {\n      return BigInt._and(a, b);\n    } else if (a.isNeg && b.isNeg) {\n      // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))\n      // == -(((x-1) | (y-1)) + 1)\n      const a1 = a._subOne(false);\n      const b1 = b._subOne(false);\n      return BigInt._or(a1, b1)._addOne(true);\n    }\n    // Assume that 'a' is the positive BigInt\n    if (a.isNeg) {\n      const temp: BigInt = a;\n      a = b;\n      b = temp;\n    }\n    // x & (-y) == x & ~(y-1) == x &~ (y-1)\n    const b1 = b._subOne(false);\n    return a._andNot(b1);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 894 lines of wat.\n   */\n  bitOr<T>(other: T): BigInt {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let a: BigInt = this;\n    let b: BigInt = BigInt.from(other);\n    if (!a.isNeg && !b.isNeg) {\n      return BigInt._or(a, b);\n    } else if (a.isNeg && b.isNeg) {\n      // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))\n      // == -(((x-1) & (y-1)) + 1)\n      const a1: BigInt = a._subOne(false);\n      const b1: BigInt = b._subOne(false);\n      return BigInt._and(a1, b1)._addOne(true);\n    } else {\n      // Assume that 'a' is the positive BigInt\n      if (a.isNeg) {\n        const temp: BigInt = a;\n        a = b;\n        b = temp;\n      }\n      // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)\n      const b1: BigInt = b._subOne(false);\n      return b1._andNot(a)._addOne(true);\n    }\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 661 lines of wat.\n   */\n  bitXor<T>(other: T): BigInt {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let a: BigInt = this;\n    let b: BigInt = BigInt.from(other);\n    if (!a.isNeg && !b.isNeg) {\n      return BigInt._xor(a, b);\n    } else if (a.isNeg && b.isNeg) {\n      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n      const a1: BigInt = a._subOne(false);\n      const b1: BigInt = b._subOne(false);\n      return BigInt._xor(a1, b1);\n    } else {\n      // Assume that 'a' is the positive BigInt\n      if (a.isNeg) {\n        const temp: BigInt = a;\n        a = b;\n        b = temp;\n      }\n      // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n      const b1: BigInt = b._subOne(false);\n      return BigInt._xor(a, b1)._addOne(true);\n    }\n  }\n\n  // unsigned bit AND\n  private static _and(a: BigInt, b: BigInt): BigInt {\n    const numPairs: i32 = a.n < b.n ? a.n : b.n;\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      numPairs,\n      false,\n      numPairs,\n    );\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = a.d[i] & b.d[i];\n    }\n    return res;\n  }\n\n  // unsigned bit AND NOT (i.e. a & ~b)\n  private _andNot(other: BigInt): BigInt {\n    const numPairs: i32 = this.n < other.n ? this.n : other.n;\n    const res: BigInt = BigInt.getEmptyResultContainer(this.n, false, this.n);\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = this.d[i] & ~other.d[i];\n    }\n    for (; i < this.n; i++) {\n      res.d[i] = this.d[i];\n    }\n    return res;\n  }\n\n  // unsigned bit OR\n  private static _or(a: BigInt, b: BigInt): BigInt {\n    let numPairs: i32;\n    let resLength: i32;\n    if (a.n > b.n) {\n      numPairs = b.n;\n      resLength = a.n;\n    } else {\n      numPairs = a.n;\n      resLength = b.n;\n    }\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      resLength,\n      false,\n      resLength,\n    );\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = a.d[i] | b.d[i];\n    }\n    for (; i < a.n; i++) {\n      res.d[i] = a.d[i];\n    }\n    for (; i < b.n; i++) {\n      res.d[i] = b.d[i];\n    }\n    return res;\n  }\n\n  // unsigned bit XOR\n  private static _xor(a: BigInt, b: BigInt): BigInt {\n    let numPairs: i32;\n    let resLength: i32;\n    if (a.n > b.n) {\n      numPairs = b.n;\n      resLength = a.n;\n    } else {\n      numPairs = a.n;\n      resLength = b.n;\n    }\n    const res: BigInt = BigInt.getEmptyResultContainer(\n      resLength,\n      false,\n      resLength,\n    );\n\n    let i = 0;\n    for (; i < numPairs; i++) {\n      res.d[i] = a.d[i] ^ b.d[i];\n    }\n    for (; i < a.n; i++) {\n      res.d[i] = a.d[i];\n    }\n    for (; i < b.n; i++) {\n      res.d[i] = b.d[i];\n    }\n    return res;\n  }\n\n  // UTILITY ///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  private countBits(): i32 {\n    if (this.n == 0) return 0;\n    // initialize to bits in fully used digits\n    let bits: i32 = (this.n - 1) * BigInt.p;\n    // count bits used in most significant digit\n    let q: u32 = this.d[this.n - 1];\n    while (q > 0) {\n      ++bits;\n      q >>= 1;\n    }\n    return bits;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 23 lines of wat.\n   */\n  isOdd(): boolean {\n    return this.n > 0 && (this.d[0] & 1) == 1;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 195 lines of wat.\n   */\n  isZero(): boolean {\n    return this == BigInt.zero();\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 174 lines of wat.\n   */\n  isI32(): boolean {\n    return (\n      BigInt.fromI32(i32.MIN_VALUE) <= this &&\n      this <= BigInt.fromI32(i32.MAX_VALUE)\n    );\n  }\n\n  private static isPow2(b: u32): i32 {\n    for (let i = 1; i < BigInt.p; i++) {\n      if (b == (<u32>1) << i) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  // SYNTAX SUGAR ///////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * BigInt with value 0\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 44 line of wat.\n   */\n  static zero(): BigInt {\n    return BigInt.fromU16(0);\n  }\n\n  // BigInt with value 1\n  private static get ONE(): BigInt {\n    return BigInt.fromU16(1);\n  }\n\n  // BigInt with value -1\n  private static get NEG_ONE(): BigInt {\n    const res: BigInt = BigInt.fromU16(1);\n    res.isNeg = true;\n    return res;\n  }\n\n  static equals<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.equals(right);\n  }\n\n  @operator(\"==\")\n  private static eqOp(left: BigInt, right: BigInt): boolean {\n    return left.equals(right);\n  }\n\n  static notEqual<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.notEqual(right);\n  }\n\n  @operator(\"!=\")\n  private static neOp(left: BigInt, right: BigInt): boolean {\n    return left.notEqual(right);\n  }\n\n  static lt<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.lt(right);\n  }\n\n  @operator(\"<\")\n  private static ltOp(left: BigInt, right: BigInt): boolean {\n    return left.lt(right);\n  }\n\n  static le<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.le(right);\n  }\n\n  @operator(\"<=\")\n  private static lteOp(left: BigInt, right: BigInt): boolean {\n    return left.le(right);\n  }\n\n  static gt<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.gt(right);\n  }\n\n  @operator(\">\")\n  private static gtOp(left: BigInt, right: BigInt): boolean {\n    return left.gt(right);\n  }\n\n  static ge<T, U>(left: T, right: U): boolean {\n    const a: BigInt = BigInt.from(left);\n    return a.ge(right);\n  }\n\n  @operator(\">=\")\n  private static gteOp(left: BigInt, right: BigInt): boolean {\n    return left.ge(right);\n  }\n\n  static plus<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.plus(right);\n  }\n\n  @operator(\"+\")\n  private static addOp(left: BigInt, right: BigInt): BigInt {\n    return left.plus(right);\n  }\n\n  static minus<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.minus(right);\n  }\n\n  @operator(\"-\")\n  private static subOp(left: BigInt, right: BigInt): BigInt {\n    return left.minus(right);\n  }\n\n  static times<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.times(right);\n  }\n\n  @operator(\"*\")\n  private static mulOp(left: BigInt, right: BigInt): BigInt {\n    return left.times(right);\n  }\n\n  static div<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.div(right);\n  }\n\n  @operator(\"/\")\n  private static divOp(left: BigInt, right: BigInt): BigInt {\n    return left.div(right);\n  }\n\n  static mod<T, U>(left: T, right: U): BigInt {\n    const a: BigInt = BigInt.from(left);\n    return a.mod(right);\n  }\n\n  @operator(\"%\")\n  private static modOp(left: BigInt, right: BigInt): BigInt {\n    return left.mod(right);\n  }\n\n  static pow<T>(base: T, k: i32): BigInt {\n    const x: BigInt = BigInt.from(base);\n    return x.pow(k);\n  }\n\n  // note: the right-hand operand must be a positive integer that fits in an i32\n  @operator(\"**\")\n  private static powOp(left: BigInt, right: BigInt): BigInt {\n    return left.pow(right.toI32());\n  }\n\n  // note: the right-hand operand must be a positive integer that fits in an i32\n  @operator(\"<<\")\n  private static leftShift(left: BigInt, right: BigInt): BigInt {\n    return left.leftShift(right.toI32());\n  }\n\n  // note: the right-hand operand must be a positive integer that fits in an i32\n  @operator(\">>\")\n  private static rightShift(left: BigInt, right: BigInt): BigInt {\n    return left.rightShift(right.toI32());\n  }\n\n  static bitNot<T>(a: T): BigInt {\n    return BigInt.from(a).bitNot();\n  }\n\n  static bitAnd<T, U>(a: T, b: U): BigInt {\n    const left: BigInt = BigInt.from(a);\n    return left.bitAnd(b);\n  }\n\n  @operator(\"&\")\n  private static bitAndOp(a: BigInt, b: BigInt): BigInt {\n    return a.bitAnd(b);\n  }\n\n  static bitOr<T, U>(a: T, b: U): BigInt {\n    const left: BigInt = BigInt.from(a);\n    return left.bitOr(b);\n  }\n\n  @operator(\"|\")\n  private static bitOrOp(a: BigInt, b: BigInt): BigInt {\n    return a.bitOr(b);\n  }\n\n  static bitXor<T, U>(a: T, b: U): BigInt {\n    const left: BigInt = BigInt.from(a);\n    return left.bitXor(b);\n  }\n\n  @operator(\"^\")\n  private static bitXorOp(a: BigInt, b: BigInt): BigInt {\n    return a.bitXor(b);\n  }\n}\n",
  "node_modules/@hyperoracle/zkgraph-lib/common/types/bytes.ts": "import * as typeConversion from \"../../utils/conversion\";\n\n/**\n * Caution! use only if you know what you want to do, otherwise it will introduce weird bug (bus error, runtime err etc.)\n */\nlet _available_ptr: usize = 60000; // in js local: max mem size == 65535 (guess)\nfunction _static_alloc(_len: usize): usize {\n  var _pre_ptr = _available_ptr;\n  _available_ptr += _len;\n  return _pre_ptr;\n}\n\n/**\n * dereference helper\n *\n * Try not to use this.\n *\n * It's a custom implementation to get the initial Hyper Oracle MVP.\n */\nexport class PtrDeref {\n  data: usize = 0;\n  static read(ptr: usize): usize {\n    return changetype<PtrDeref>(ptr).data;\n  }\n  static write(ptr: usize, val: usize): void {\n    changetype<PtrDeref>(ptr).data = val;\n  }\n}\n\n/**\n * ByteArray Class\n */\nexport class ByteArray extends Uint8Array {\n  /**\n   * Returns bytes in little-endian order.\n   *\n   * Note: Ethereum uses big-endian order.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static fromI32LittleEndian(x: i32): ByteArray {\n    const self = new ByteArray(4);\n    self[0] = x as u8;\n    self[1] = (x >> 8) as u8;\n    self[2] = (x >> 16) as u8;\n    self[3] = (x >> 24) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static fromI32BigEndian(x: i32): ByteArray {\n    const self = new ByteArray(4);\n    self[3] = x as u8;\n    self[2] = (x >> 8) as u8;\n    self[1] = (x >> 16) as u8;\n    self[0] = (x >> 24) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order by default.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static fromI32(x: i32): ByteArray {\n    return ByteArray.fromI32BigEndian(x);\n  }\n\n  /**\n   * Returns bytes in little-endian order.\n   *\n   * Note: Ethereum uses big-endian order.\n   * If your input is big-endian, call `.reverse()` first.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static fromU32LittleEndian(x: u32): ByteArray {\n    const self = new ByteArray(4);\n    self[0] = x as u8;\n    self[1] = (x >> 8) as u8;\n    self[2] = (x >> 16) as u8;\n    self[3] = (x >> 24) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static fromU32BigEndian(x: u32): ByteArray {\n    const self = new ByteArray(4);\n    self[3] = x as u8;\n    self[2] = (x >> 8) as u8;\n    self[1] = (x >> 16) as u8;\n    self[0] = (x >> 24) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order by default.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static fromU32(x: u32): ByteArray {\n    return ByteArray.fromU32BigEndian(x);\n  }\n\n  /**\n   * Returns bytes in little-endian order.\n   *\n   * Note: Ethereum uses big-endian order.\n   * If your input is big-endian, call `.reverse()` first.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 lines of wat.\n   */\n  static fromI64LittleEndian(x: i64): ByteArray {\n    const self = new ByteArray(8);\n    self[0] = x as u8;\n    self[1] = (x >> 8) as u8;\n    self[2] = (x >> 16) as u8;\n    self[3] = (x >> 24) as u8;\n    self[4] = (x >> 32) as u8;\n    self[5] = (x >> 40) as u8;\n    self[6] = (x >> 48) as u8;\n    self[7] = (x >> 56) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 lines of wat.\n   */\n  static fromI64BigEndian(x: i64): ByteArray {\n    const self = new ByteArray(8);\n    self[7] = x as u8;\n    self[6] = (x >> 8) as u8;\n    self[5] = (x >> 16) as u8;\n    self[4] = (x >> 24) as u8;\n    self[3] = (x >> 32) as u8;\n    self[2] = (x >> 40) as u8;\n    self[1] = (x >> 48) as u8;\n    self[0] = (x >> 56) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order by default.\n   *\n   * WASM cost: 111 lines of wat.\n   */\n  static fromI64(x: i64): ByteArray {\n    return ByteArray.fromI64BigEndian(x);\n  }\n\n  /**\n   * Returns bytes in little-endian order.\n   *\n   * Note: Ethereum uses big-endian order.\n   * If your input is big-endian, call `.reverse()` first.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 lines of wat.\n   */\n  static fromU64LittleEndian(x: u64): ByteArray {\n    const self = new ByteArray(8);\n    self[0] = x as u8;\n    self[1] = (x >> 8) as u8;\n    self[2] = (x >> 16) as u8;\n    self[3] = (x >> 24) as u8;\n    self[4] = (x >> 32) as u8;\n    self[5] = (x >> 40) as u8;\n    self[6] = (x >> 48) as u8;\n    self[7] = (x >> 56) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 lines of wat.\n   */\n  static fromU64BigEndian(x: u64): ByteArray {\n    const self = new ByteArray(8);\n    self[7] = x as u8;\n    self[6] = (x >> 8) as u8;\n    self[5] = (x >> 16) as u8;\n    self[4] = (x >> 24) as u8;\n    self[3] = (x >> 32) as u8;\n    self[2] = (x >> 40) as u8;\n    self[1] = (x >> 48) as u8;\n    self[0] = (x >> 56) as u8;\n    return self;\n  }\n\n  /**\n   * Returns bytes in big-endian order by default.\n   *\n   * WASM cost: 111 lines of wat.\n   */\n  static fromU64(x: u64): ByteArray {\n    return ByteArray.fromU64BigEndian(x);\n  }\n\n  /**\n   * Returns empty ByteArray.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 lines of wat.\n   */\n  static empty(): ByteArray {\n    return ByteArray.fromI32(0);\n  }\n\n  /**\n   * Convert the string `hex` which must consist of an even number of\n   * hexadecimal digits to a `ByteArray`. The string `hex` can optionally\n   * start with '0x'\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1396 lines of wat. //TODO: update this\n   */\n  static fromHexString(hex: string): ByteArray {\n    // assert(hex.length % 2 == 0, \"input has odd length\");\n    // Skip possible `0x` prefix.\n    if (hex.length >= 2 && hex.charAt(0) == \"0\" && hex.charAt(1) == \"x\") {\n      hex = hex.substr(2);\n    }\n\n    // padding prefix 0 when odd len\n    if (hex.length % 2 != 0) hex = \"0\" + hex;\n\n    const output = new Bytes(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n      // @deprecated  Converts a string to an integer of this type. Please use \"i32.parse\" method.\n      // The .wat diff is using I8.parseInt has an additional i32.extend8_s (Unknown opcode 192 (0xC0) in zkwasm).\n      // output[i / 2] = I8.parseInt(hex.substr(i, 2), 16);\n\n      // @deprecated  Converts a string to an integer of this type. Please use \"i32.parse\" method.\n      // output[i / 2] = I32.parseInt(hex.substr(i, 2), 16);\n\n      output[i / 2] = i32.parse(hex.substr(i, 2), 16);\n    }\n    return output;\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 275 lines of wat.\n   */\n  static fromUTF8(str: string): ByteArray {\n    const utf8 = String.UTF8.encode(str);\n    return changetype<ByteArray>(ByteArray.wrap(utf8));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1121 lines of wat.\n   */\n  toHex(): string {\n    return typeConversion.bytesToHex(this);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1121 lines of wat.\n   */\n  toHexString(): string {\n    return typeConversion.bytesToHex(this);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 951 lines of wat.\n   */\n  toString(): string {\n    return typeConversion.bytesToString(this);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 421 lines of wat.\n   */\n  toBase58(): string {\n    return typeConversion.bytesToBase58(this);\n  }\n\n  /**\n   * Interprets the byte array as a little-endian U32.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 241 lines of wat.\n   */\n  toU32(): u32 {\n    for (let i = 4; i < this.length; i++) {\n      if (this[i] != 0) {\n        assert(false, \"overflow converting this to u32\");\n      }\n    }\n    const paddedBytes = new Bytes(4);\n    paddedBytes[0] = 0;\n    paddedBytes[1] = 0;\n    paddedBytes[2] = 0;\n    paddedBytes[3] = 0;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: u32 = 0;\n    x = (x | paddedBytes[3]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = x | paddedBytes[0];\n    return x;\n  }\n\n  /**\n   * Interprets the byte array as a big-endian U32.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 198 lines of wat.\n   */\n  toU32BigEndian(): u32 {\n    for (let i = 0; i < this.length - 4; i++) {\n      if (this[i] != 0) {\n        assert(false, \"overflow converting this to u32\");\n      }\n    }\n    const paddedBytes = new Bytes(4);\n    paddedBytes[0] = 0;\n    paddedBytes[1] = 0;\n    paddedBytes[2] = 0;\n    paddedBytes[3] = 0;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: u32 = 0;\n    x = (x | paddedBytes[0]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = x | paddedBytes[3];\n    return x;\n  }\n\n  /**\n   * Interprets the byte array as a little-endian I32.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 230 lines of wat.\n   */\n  toI32(): i32 {\n    const isNeg = this.length > 0 && this[this.length - 1] >> 7 == 1;\n    const padding = isNeg ? 255 : 0;\n    for (let i = 4; i < this.length; i++) {\n      if (this[i] != padding) {\n        assert(false, \"overflow converting this to i32\");\n      }\n    }\n    const paddedBytes = new Bytes(4);\n    paddedBytes[0] = padding;\n    paddedBytes[1] = padding;\n    paddedBytes[2] = padding;\n    paddedBytes[3] = padding;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: i32 = 0;\n    x = (x | paddedBytes[3]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = x | paddedBytes[0];\n    return x;\n  }\n\n  /**\n   * Interprets the byte array as a big-endian I32.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 222 lines of wat.\n   */\n  toI32BigEndian(): i32 {\n    const isNeg = this.length > 0 && this[0] >> 7 == 1;\n    const padding = isNeg ? 255 : 0;\n    for (let i = 0; i < this.length - 4; i++) {\n      if (this[i] != padding) {\n        assert(false, \"overflow converting to this i32\");\n      }\n    }\n    const paddedBytes = new Bytes(4);\n    paddedBytes[0] = padding;\n    paddedBytes[1] = padding;\n    paddedBytes[2] = padding;\n    paddedBytes[3] = padding;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: i32 = 0;\n    x = (x | paddedBytes[0]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = x | paddedBytes[3];\n    return x;\n  }\n\n  /** Create a new `ByteArray` that consist of `this` directly followed by\n   * the bytes from `other`\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 917 lines of wat.\n   */\n  concat(other: ByteArray): ByteArray {\n    const newArray = new ByteArray(this.length + other.length);\n    newArray.set(this, 0);\n    newArray.set(other, this.length);\n    return newArray;\n  }\n\n  /** Create a new `ByteArray` that consists of `this` directly followed by\n   * the representation of `other` as bytes\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 928 lines of wat.\n   */\n  concatI32(other: i32): ByteArray {\n    return this.concat(ByteArray.fromI32(other));\n  }\n\n  /**\n   * Interprets the byte array as a little-endian I64.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 325 lines of wat.\n   */\n  toI64(): i64 {\n    const isNeg = this.length > 0 && this[this.length - 1] >> 7 == 1;\n    const padding = isNeg ? 255 : 0;\n    for (let i = 8; i < this.length; i++) {\n      if (this[i] != padding) {\n        assert(false, \"overflow converting to this i64\");\n      }\n    }\n    const paddedBytes = new Bytes(8);\n    paddedBytes[0] = padding;\n    paddedBytes[1] = padding;\n    paddedBytes[2] = padding;\n    paddedBytes[3] = padding;\n    paddedBytes[4] = padding;\n    paddedBytes[5] = padding;\n    paddedBytes[6] = padding;\n    paddedBytes[7] = padding;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: i64 = 0;\n    x = (x | paddedBytes[7]) << 8;\n    x = (x | paddedBytes[6]) << 8;\n    x = (x | paddedBytes[5]) << 8;\n    x = (x | paddedBytes[4]) << 8;\n    x = (x | paddedBytes[3]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = x | paddedBytes[0];\n    return x;\n  }\n\n  /**\n   * Interprets the byte array as a big-endian I64.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 317 lines of wat.\n   */\n  toI64BigEndian(): i64 {\n    const isNeg = this.length > 0 && this[0] >> 7 == 1;\n    const padding = isNeg ? 255 : 0;\n    for (let i = 0; i < this.length - 8; i++) {\n      if (this[i] != padding) {\n        assert(false, \"overflow converting this to i64\");\n      }\n    }\n    const paddedBytes = new Bytes(8);\n    paddedBytes[0] = padding;\n    paddedBytes[1] = padding;\n    paddedBytes[2] = padding;\n    paddedBytes[3] = padding;\n    paddedBytes[4] = padding;\n    paddedBytes[5] = padding;\n    paddedBytes[6] = padding;\n    paddedBytes[7] = padding;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: i64 = 0;\n    x = (x | paddedBytes[0]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = (x | paddedBytes[3]) << 8;\n    x = (x | paddedBytes[4]) << 8;\n    x = (x | paddedBytes[5]) << 8;\n    x = (x | paddedBytes[6]) << 8;\n    x = x | paddedBytes[7];\n    return x;\n  }\n\n  /**\n   * Interprets the byte array as a little-endian U64.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 293 lines of wat.\n   */\n  toU64(): u64 {\n    for (let i = 8; i < this.length; i++) {\n      if (this[i] != 0) {\n        assert(false, \"overflow converting this to u64\");\n      }\n    }\n    const paddedBytes = new Bytes(8);\n    paddedBytes[0] = 0;\n    paddedBytes[1] = 0;\n    paddedBytes[2] = 0;\n    paddedBytes[3] = 0;\n    paddedBytes[4] = 0;\n    paddedBytes[5] = 0;\n    paddedBytes[6] = 0;\n    paddedBytes[7] = 0;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: u64 = 0;\n    x = (x | paddedBytes[7]) << 8;\n    x = (x | paddedBytes[6]) << 8;\n    x = (x | paddedBytes[5]) << 8;\n    x = (x | paddedBytes[4]) << 8;\n    x = (x | paddedBytes[3]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = x | paddedBytes[0];\n    return x;\n  }\n\n  /**\n   * Interprets the byte array as a big-endian U64.\n   * Throws in case of overflow.\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 293 lines of wat.\n   */\n  toU64BigEndian(): u64 {\n    for (let i = 0; i < this.length - 8; i++) {\n      if (this[i] != 0) {\n        assert(false, \"overflow converting this to u64\");\n      }\n    }\n    const paddedBytes = new Bytes(8);\n    paddedBytes[0] = 0;\n    paddedBytes[1] = 0;\n    paddedBytes[2] = 0;\n    paddedBytes[3] = 0;\n    paddedBytes[4] = 0;\n    paddedBytes[5] = 0;\n    paddedBytes[6] = 0;\n    paddedBytes[7] = 0;\n    const minLen =\n      paddedBytes.length < this.length ? paddedBytes.length : this.length;\n    for (let i = 0; i < minLen; i++) {\n      paddedBytes[i] = this[i];\n    }\n    let x: u64 = 0;\n    x = (x | paddedBytes[0]) << 8;\n    x = (x | paddedBytes[1]) << 8;\n    x = (x | paddedBytes[2]) << 8;\n    x = (x | paddedBytes[3]) << 8;\n    x = (x | paddedBytes[4]) << 8;\n    x = (x | paddedBytes[5]) << 8;\n    x = (x | paddedBytes[6]) << 8;\n    x = x | paddedBytes[7];\n    return x;\n  }\n\n  //TODO: Fast equals\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 52 lines of wat.\n   */\n  @operator(\"==\")\n  equals(other: ByteArray): boolean {\n    if (this.length != other.length) {\n      return false;\n    }\n    for (let i = 0; i < this.length; i++) {\n      if (this[i] != other[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  eq(other: ByteArray): boolean {\n    return this.equals(other);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 52 lines of wat.\n   */\n  @operator(\"!=\")\n  notEqual(other: ByteArray): boolean {\n    return !(this == other);\n  }\n\n  ne(other: ByteArray): boolean {\n    return this.notEqual(other);\n  }\n}\n\n/**\n * Bytes class\n * Uint8Array with clean 'new' and fill without memory.fill\n */\nexport class Bytes extends ByteArray {\n  // Functions from initial implementations\n  // Custom implementations to get the initial Hyper Oracle MVP.\n  // -----------------------------------------------------------\n  /**\n   * Try not to use this.\n   *\n   * It's a custom implementation to get the initial Hyper Oracle MVP.\n   */\n  static new(_len: i32): Bytes {\n    var _bytes_ptr = _static_alloc(12);\n    var _arr_data_ptr = _static_alloc(_len);\n    // write data ptr to the 0th, 1st fields of Array<u8>\n    PtrDeref.write(_bytes_ptr, _arr_data_ptr);\n    PtrDeref.write(_bytes_ptr + 4, _arr_data_ptr);\n    PtrDeref.write(_bytes_ptr + 8, _len);\n    // _available_ptr += (12+_len)\n    // _available_ptr += 2 // just for nop\n    var _bytes = changetype<Bytes>(_bytes_ptr);\n    // write data len to the 2nd, 3rd fields of Array<u8>, equivalent to .length=_len\n    return _bytes;\n  }\n\n  /**\n   * Try not to use this.\n   *\n   * It's a custom implementation to get the initial Hyper Oracle MVP.\n   */\n  static fromRawarrPtr(_arr_heap_ptr: usize, _len: i32): Bytes {\n    var _tmpu8a = new Uint8Array(0);\n    var _bytes_ptr = changetype<i32>(_tmpu8a);\n\n    store<u32>(_bytes_ptr, _arr_heap_ptr);\n    store<u32>(_bytes_ptr + 4, _arr_heap_ptr);\n    store<u32>(_bytes_ptr + 8, _len);\n    return Bytes.fromU8Array(_tmpu8a);\n    // return changetype<Bytes>(_bytes_ptr);\n\n    // Plan A\n    // PtrDeref.write(_bytes_ptr, _arr_heap_ptr);\n    // PtrDeref.write(_bytes_ptr + 4, _arr_heap_ptr);\n    // PtrDeref.write(_bytes_ptr + 8, _len);\n\n    // Plan B\n    // memory.copy(_tmpu8a.dataStart, _arr_heap_ptr, _len);\n    // return Bytes.fromU8Array(_tmpu8a)\n\n    // Plan C\n    // var _bytes_ptr = heap.alloc(12); // size of Uint8Array == 3*4 == 12\n    // var _bytes_ptr = _static_alloc(12);\n\n    // Debug\n    // console.log(PtrDeref.read(_bytes_ptr).toString())\n    // console.log(PtrDeref.read(_bytes_ptr+4).toString())\n    // console.log(PtrDeref.read(_bytes_ptr+8).toString())\n  }\n\n  toRawarrPtr(): usize {\n    return PtrDeref.read(changetype<usize>(this));\n  }\n\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 133 line of wat.\n   */\n  slice(start: i32 = 0, end: i32 = this.length): Bytes {\n    const len = this.length;\n\n    // Original Bytes is empty.\n    if (len === 0) return Bytes.empty();\n\n    // Handle last index\n    if (end === -1) end = len;\n\n    // Handle error inputs\n    if (start >= end) {\n      return Bytes.empty();\n    }\n\n    return Bytes.fromU8Array(super.slice(start, end));\n  }\n\n  /**\n   * Try not to use this.\n   *\n   * It's a custom implementation to get the initial Hyper Oracle MVP.\n   */\n  _slice(start: i32, end: i32): Bytes {\n    if (\n      start < 0 ||\n      end < 0 ||\n      start > this.length ||\n      end > this.length ||\n      start >= end\n    ) {\n      return new Bytes(0);\n      // throw new Error(\"Invalid slice parameters\");\n    }\n\n    const len = end - start;\n    var dst = new Bytes(len);\n    for (let i: i32 = 0; i < len; i++) {\n      dst[i] = this[start + i];\n    }\n\n    return dst;\n  }\n\n  // Disabled due to the existence of implementation of ByteArray\n  // toU32(): u32 {\n  //   assert(this.length <= 4);\n  //   var rst: u32 = 0;\n  //   for (var i = 0; i < min(4, this.length); i++) {\n  //     rst = rst << 8;\n  //     rst += this[i];\n  //   }\n  //   return rst;\n  // }\n\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 65 line of wat.\n   */\n  padStart(targetLength: i32, padDigit: u8 = 0): Bytes {\n    return this.padTo(targetLength, true, padDigit);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 65 line of wat.\n   */\n  padEnd(targetLength: i32, padDigit: u8 = 0): Bytes {\n    return this.padTo(targetLength, false, padDigit);\n  }\n\n  private padTo(\n    targetLength: i32,\n    isPadStart: bool = true,\n    padDigit: u8 = 0,\n  ): Bytes {\n    if (targetLength <= this.length) return this;\n\n    // Prepare padding bytes\n    let _padding = new Bytes(targetLength - this.length);\n    if (padDigit != 0) {\n      _padding.fill(padDigit);\n    }\n    // Concat\n    let rst: ByteArray;\n    if (isPadStart) {\n      // pre-padding\n      rst = _padding.concat(this);\n    } else {\n      // post-padding\n      rst = this.concat(_padding);\n    }\n    return changetype<Bytes>(rst);\n  }\n\n  // Disabled due to the existence of implementation of ByteArray\n  // @operator(\"==\")\n  // __opeq(right: Bytes): bool {\n  //   if (this.length != right.length) {\n  //     // console.log(this.length.toString() + '---' + right.length.toString());\n  //     return false;\n  //   }\n  //   for (var i = 0; i < this.length; i++) {\n  //     if (this[i] != right[i]) {\n  //       return false;\n  //     }\n  //   }\n  //   return true;\n  // }\n  // --------------------------------------\n\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 0 line of wat.\n   */\n  static fromByteArray(byteArray: ByteArray): Bytes {\n    return changetype<Bytes>(byteArray);\n  }\n\n  /**\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 0 line of wat.\n   */\n  static fromU8Array(uint8Array: Uint8Array): Bytes {\n    return changetype<Bytes>(uint8Array);\n  }\n\n  /**\n   * Convert the string `hex` which must consist of an even number of\n   * hexadecimal digits to a `ByteArray`. The string `hex` can optionally\n   * start with '0x'\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 1396 line of wat.\n   */\n  static fromHexString(str: string): Bytes {\n    return changetype<Bytes>(ByteArray.fromHexString(str));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 279 line of wat.\n   */\n  static fromUTF8(str: string): Bytes {\n    return Bytes.fromByteArray(ByteArray.fromUTF8(str));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static fromI32LittleEndian(i: i32): Bytes {\n    return changetype<Bytes>(ByteArray.fromI32LittleEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static fromI32BigEndian(i: i32): Bytes {\n    return changetype<Bytes>(ByteArray.fromI32BigEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static fromI32(i: i32): Bytes {\n    return changetype<Bytes>(ByteArray.fromI32(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static fromU32LittleEndian(i: u32): Bytes {\n    return changetype<Bytes>(ByteArray.fromU32LittleEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static fromU32BigEndian(i: u32): Bytes {\n    return changetype<Bytes>(ByteArray.fromU32BigEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static fromU32(i: u32): Bytes {\n    return changetype<Bytes>(ByteArray.fromU32(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 line of wat.\n   */\n  static fromI64LittleEndian(i: i64): Bytes {\n    return changetype<Bytes>(ByteArray.fromI64LittleEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 line of wat.\n   */\n  static fromI64BigEndian(i: i64): Bytes {\n    return changetype<Bytes>(ByteArray.fromI64BigEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 line of wat.\n   */\n  static fromI64(i: i64): Bytes {\n    return changetype<Bytes>(ByteArray.fromI64(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 line of wat.\n   */\n  static fromU64LittleEndian(i: u64): Bytes {\n    return changetype<Bytes>(ByteArray.fromU64LittleEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 line of wat.\n   */\n  static fromU64BigEndian(i: u64): Bytes {\n    return changetype<Bytes>(ByteArray.fromU64BigEndian(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 111 line of wat.\n   */\n  static fromU64(i: u64): Bytes {\n    return changetype<Bytes>(ByteArray.fromU64(i));\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 67 line of wat.\n   */\n  static empty(): Bytes {\n    return changetype<Bytes>(ByteArray.empty());\n  }\n\n  // Disabled for now\n  // (ERROR TS2394: This overload signature is not compatible with its implementation signature.)\n  // concat(other: Bytes): Bytes {\n  //   return changetype<Bytes>(super.concat(other));\n  // }\n\n  // concatI32(other: i32): Bytes {\n  //   return changetype<Bytes>(super.concat(ByteArray.fromI32(other)));\n  // }\n}\n\n/** An Ethereum address (20 bytes). */\nexport class Address extends Bytes {\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 126 line of wat.\n   */\n  static fromString(s: string): Address {\n    return changetype<Address>(typeConversion.stringToH160(s));\n  }\n\n  /** Convert `Bytes` that must be exactly 20 bytes long to an address.\n   * Passing in a value with fewer or more bytes will result in an error\n   *\n   * Provable on zkWASM.\n   *\n   * WASM cost: 9 line of wat.\n   */\n  static fromBytes(b: Bytes): Address {\n    if (b.length != 20) {\n      throw new Error(\n        // `Bytes of length ${b.length} can not be converted to 20 byte addresses`\n        // Don't use ${} in error message for better performance in zkWASM\n        `Bytes of length of (not 20) can not be converted to 20 byte addresses`,\n      );\n    }\n    return changetype<Address>(b);\n  }\n\n  /**\n   * Provable on zkWASM.\n   *\n   * WASM cost: 44 line of wat.\n   */\n  static zero(): Address {\n    const self = new ByteArray(20);\n\n    for (let i = 0; i < 20; i++) {\n      self[i] = 0;\n    }\n\n    return changetype<Address>(self);\n  }\n}\n",
  "node_modules/@hyperoracle/zkgraph-lib/common/zkwasm.ts": "// import { Bytes } from \"./type\";\nimport { Bytes } from \"./type\";\n\n\n// used in asc to rm env.abort\nfunction abort(a:usize, b:usize, c:u32, d:u32):void{}\n\n// @ts-ignore\n@external(\"env\", \"wasm_input\")\nexport declare function wasm_input(x: i32): i64\n\n// @ts-ignore\n@external(\"env\", \"require\")\nexport declare function require(x: bool): void\n\nexport function wasm_private_input(): i64\n{\n  return wasm_input(0);\n}\n\nexport function wasm_public_input(): i64\n{\n  return wasm_input(1);\n}\n\nexport function read_bytes_from_u64_to_dst(dst: Bytes, byte_length: i32, input_type: i32): Bytes {\n    var dst64 = changetype<Uint64Array>(dst);\n    for (var i:i32 = 0; i * 8 < byte_length; i++)\n    {\n        if (i * 8 + 8 < byte_length)\n        {\n            dst64[i] = wasm_input(input_type);\n        }\n        else\n        {\n            // less then 8 bytes on demand\n            var u64_cache = wasm_input(input_type);\n            var u8_cache: i64 = u64_cache;\n            for (var j:i32 = i * 8; j < byte_length; j++)\n            {\n                let u8_t =  u8_cache as u8;\n                dst[j] = u8_t;\n                u8_cache = u8_cache >> 8\n            }\n        }\n    }\n    return dst;\n}\n\nexport function read_private_bytes_from_u64(byte_length: i32): Bytes {\n    var dst = new Bytes(byte_length);\n    read_bytes_from_u64_to_dst(dst, byte_length, 0);\n    return dst;\n}\nexport function read_public_bytes_from_u64(byte_length: i32): Bytes {\n    var dst = new Bytes(byte_length);\n    read_bytes_from_u64_to_dst(dst, byte_length, 1);\n    return dst;\n}\n\nexport function read_private_len_then_bytes(): Bytes {\n    var blen = wasm_private_input() as i32;\n    var bytes = read_private_bytes_from_u64(blen);\n    return bytes;\n}\n\nexport function read_public_len_then_bytes(): Bytes {\n    var blen = wasm_public_input() as i32;\n    var bytes = read_public_bytes_from_u64(blen);\n    return bytes;\n}\n\nexport function read_private_array_of_len_then_bytes(): Bytes[] {\n    const size = wasm_private_input() as i32;\n    let arr = new Array<Bytes>(size);\n    for (let i = 0; i < size; i ++){\n        arr[i] = read_private_len_then_bytes();\n    }\n    return arr;\n}",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum/index.ts": "// each dsp should export zkmain_lib, asmain_lib, registerHandle. \n// should always use the same name, because will import like `import { registerHandle }  from xxx/dsp/ethereum/index`\nexport { zkmain_lib, asmain_lib } from \"./main\";\nexport { registerHandle } from \"./register\";\n// class Block, Event, Account, Slot\nexport * from \"./type\";",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum/main.ts": "import { Bytes } from \"../../common/type\";\nimport {\n  read_public_bytes_from_u64,\n  read_public_len_then_bytes,\n  // @ts-ignore\n  require,\n} from \"../../common/zkwasm\";\nimport { handleFunc } from './register';\nimport { readBlocks } from \"./readblock\";\n\nexport function zkmain_lib(): void {\n\n  let blocks = readBlocks();\n\n  const blockhash_latest = read_public_bytes_from_u64(32);\n\n  const expected_state = read_public_len_then_bytes();\n\n  const state: Bytes = handleFunc(blocks) as Bytes;\n\n  require(state == expected_state ? 1 : 0);\n}\n\nexport function asmain_lib(): Uint8Array {\n\n  let blocks = readBlocks();\n\n  const blockhash_latest = read_public_bytes_from_u64(32);\n\n  const state: Bytes = handleFunc(blocks) as Bytes;\n\n  return state as Uint8Array;\n}\n",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum/packevents.ts": "// Import mapping when added as a dependency for zkGraph.\n// @ts-ignore\n// import { handleEvents } from './register'\n// import { Event, Bytes } from \"./type\";\n// Import from package itself to avoid the error below when compiling zkGraph.\n// ERROR TS2322: Type '~lib/array/Array<node_modules/@hyperoracle/zkgraph-lib/common/types/event/Event>' is not assignable to type '~lib/array/Array<~lib/@hyperoracle/zkgraph-lib/common/types/event/Event>'.\n// @ts-ignore\nimport { Bytes } from \"../../common/type\";\nimport { PtrDeref } from \"../../common/types/bytes\";\nimport { Event } from \"./type\";\n/**\n *\n * @param raw_receipts_ptr\n * @param match_event_cnt\n * @param matched_event_offsets_ptr int Uint32Array format, note that each item is read as little endian to align with PtrDeref.read and remain minimum wasmbin size\n * @returns\n */\nexport function packMatchedEvents(\n  raw_receipts_ptr: usize,\n  match_event_cnt: i32,\n  matched_event_offsets_ptr: usize,\n// ): Uint8Array {\n): Array<Event> {\n  var events = new Array<Event>(0);\n  const addressLength = 20;\n  const topicLength = 32;\n\n  for (var i = 0; i < match_event_cnt; i++) {\n    const event_base_ptr = matched_event_offsets_ptr + i * 28;\n\n    const address = Bytes.fromRawarrPtr(\n      raw_receipts_ptr + PtrDeref.read(event_base_ptr),\n      addressLength,\n    );\n    const esig = Bytes.fromRawarrPtr(\n      raw_receipts_ptr + PtrDeref.read(event_base_ptr + 1 * 4),\n      topicLength,\n    );\n\n    const topic1Offset = PtrDeref.read(event_base_ptr + 2 * 4);\n    const topic1 =\n      topic1Offset == 0\n        ? new Bytes(0)\n        : Bytes.fromRawarrPtr(raw_receipts_ptr + topic1Offset, topicLength);\n\n    const topic2Offset = PtrDeref.read(event_base_ptr + 3 * 4);\n    const topic2 =\n      topic2Offset == 0\n        ? new Bytes(0)\n        : Bytes.fromRawarrPtr(raw_receipts_ptr + topic2Offset, topicLength);\n\n    const topic3Offset = PtrDeref.read(event_base_ptr + 4 * 4);\n    const topic3 =\n      topic3Offset == 0\n        ? new Bytes(0)\n        : Bytes.fromRawarrPtr(raw_receipts_ptr + topic3Offset, topicLength);\n\n    const dataOffset = PtrDeref.read(event_base_ptr + 5 * 4);\n    const data =\n      dataOffset == 0\n        ? new Bytes(0)\n        : Bytes.fromRawarrPtr(\n            raw_receipts_ptr + dataOffset,\n            PtrDeref.read(event_base_ptr + 6 * 4) as i32,\n          );\n    events.push(new Event(address, esig, topic1, topic2, topic3, data));\n  }\n\n  // var state = handleEvents(events);\n  // return state as Uint8Array;\n  return events;\n}\n",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum/readblock.ts": "import {\n  wasm_private_input,\n  read_private_bytes_from_u64,\n  read_private_len_then_bytes,\n  read_private_array_of_len_then_bytes,\n} from \"../../common/zkwasm\";\nimport { U256_LEN, MAX_EVENTS, MAX_BLOCK_LENGTH } from \"../../common/constants\";\nimport { packMatchedEvents } from \"./packevents\";\nimport { Block, Slot, Account } from \"./type\";\n\ndeclare function matchEventsOnRLP(stream: usize, len: u32, retMatchEvents: usize): u32;\ndeclare function constraintsEvent(blockhash: usize, blocknumber: u32, receiptroot: usize): boolean;\n\n\n// @ts-ignore\n@external(\"env\", \"wasm_write_context\")\nexport declare function wasm_write_context(v: u64): void\n\nexport function readBlocks(): Array<Block> {\n  const blockCount: i32 = wasm_private_input() as i32;\n\n  //TODO: assert block count <= MAX_BLOCK_LENGTH\n\n  let blocks = new Array<Block>(0);\n  for (let i = 0; i < blockCount; i++){\n      let blockNumber = wasm_private_input();\n      let rlpHeader = read_private_len_then_bytes();\n      // for batch\n      wasm_write_context(blockNumber);\n      \n      let block = new Block(rlpHeader, blockNumber);\n\n      let accountCount: i32 = wasm_private_input() as i32;\n      for (let j = 0; j < accountCount; j++){\n          let address = read_private_bytes_from_u64(20);\n          let rlpNode = read_private_len_then_bytes();\n          let accountProof = read_private_array_of_len_then_bytes();\n          let account = new Account(address, rlpNode, accountProof);\n\n          let slotCount: i32 = wasm_private_input() as i32;\n          for (let k = 0; k < slotCount; k++){\n              let key = read_private_bytes_from_u64(32);\n              let value = read_private_len_then_bytes();\n              let storageProof = read_private_array_of_len_then_bytes();\n\n              account.slots.push(new Slot(key, value, storageProof))\n          }\n\n          block.accounts.push(account)\n      }\n\n      // Reading rlp(receipt)s. \n      let receiptscount: i32 = wasm_private_input() as i32;\n      if (receiptscount > 0) {\n        let rawreceipts = read_private_len_then_bytes();\n\n        // Call c for match events\n        let matchedEventOffsets = new Uint32Array(MAX_EVENTS * 7); // TODO: u32?\n        let matchedEventCnt = matchEventsOnRLP(rawreceipts.dataStart, rawreceipts.length, matchedEventOffsets.dataStart);\n\n        // Pack match offsets to Event[]\n        let events = packMatchedEvents(\n          rawreceipts.dataStart,\n          matchedEventCnt,\n          matchedEventOffsets.dataStart,\n        );\n          \n        // Add Events to block\n        block.setEvents(events)\n      }\n\n      blocks.push(block);\n  }\n\n  // padding to MAX_BLOCK_LENGTH, required by the batcher\n  if (blockCount < MAX_BLOCK_LENGTH) {\n    for(let i = blockCount; i < MAX_BLOCK_LENGTH; i ++ ) {\n      wasm_write_context(blocks[blockCount-1].number);\n    }\n  }\n\n  return blocks;\n}",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum/register.ts": "import { Block } from \"./type\";\nimport { Bytes } from \"../../common/type\";\n\n// export type HandleEvents = (events: Event[]) => Bytes\n\n// export let handleEvents: HandleEvents = () => {\n//   return new Bytes(0);\n// };\n\n// export function registerHandle1(handle: HandleEvents): void {\n//   handleEvents = handle\n// }\n\nexport type HandleFunc = (blocks: Block[]) => Bytes\n\nexport let handleFunc: HandleFunc = () => {\n  return new Bytes(0);\n};\n\nexport function registerHandle(handle: HandleFunc): void {\n  handleFunc = handle\n}\n",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum/type.ts": "//@ts-ignore\nimport { require } from \"../../common/zkwasm\";\nimport { Bytes } from \"../../common/types/bytes\";\n\nexport class Event {\n    constructor(\n      public address: Bytes,\n      public esig: Bytes,\n      public topic1: Bytes,\n      public topic2: Bytes,\n      public topic3: Bytes,\n      public data: Bytes,\n    ) {}\n}\n\nexport class Slot {\n    constructor(\n        public key: Bytes,\n        public value: Bytes,\n        public storageProof: Bytes[],\n    ) {}\n}\n  export class Account {\n    public events: Event[] = new Array<Event>(0);\n    public slots: Slot[] = new Array<Slot>(0);\n\n    constructor(\n        public address: Bytes,\n\n        public rlpNode: Bytes,\n        public accountProof: Bytes[],\n    ) {}\n    //TODO: order / uniqueness\n    getSlotId(key: Bytes): i32 {\n        let i: i32;\n\n        for (i = 0; i < this.slots.length; i ++) {\n            if (this.slots[i].key == key){\n                break;\n            }\n        }\n        return i == this.slots.length ? -1 : i;\n    }\n\n    hasSlot(key: Bytes): bool {\n        return this.getSlotId(key) != -1;\n    }\n\n    storage(key: Bytes): Bytes {\n        let id = this.getSlotId(key);\n        // require(id >= 0); // removed to avoid confusion\n        return this.slots[id].value;\n    }\n\n    eventsByEsig(esig: Bytes): Event[] {\n      let es = new Array<Event>(0);\n\n      for (let i = 0; i < this.events.length; i ++) {\n          if (this.events[i].esig == esig){\n              es.push(this.events[i])\n          }\n      }\n      return es;\n    }\n\n  }\n  \n  export class Block {\n      public events: Event[] = new Array<Event>(0)\n      public accounts: Account[] = new Array<Account>(0)\n      // public number: i64 = 0\n      // private rawreceipts: Bytes = new Bytes(0)\n  \n      constructor(\n        public rlpHeader: Bytes,\n        public number: i64\n      ) {}\n\n      addEvent(event: Event): void {\n        this.events.push(event);\n        let acctId = this.createAccountIfHasnt(event.address);\n        this.accounts[acctId].events.push(event);\n      }\n\n      setEvents(events: Event[]): void {\n        this.events = events;\n        // only ~150 lines of wat\n        for (let i = 0; i < events.length; i++){\n          let acctId = this.createAccountIfHasnt(events[i].address);\n          this.accounts[acctId].events.push(events[i]);\n        }\n      }\n  \n      getAccountId(address: Bytes): i32 {\n          let i: i32;\n          for (i = 0; i < this.accounts.length; i ++) {\n              if (this.accounts[i].address == address){\n                  break;\n              }\n          }\n          return i == this.accounts.length ? -1 : i;\n      }\n  \n      hasAccount(address: Bytes): bool {\n          return this.getAccountId(address) != -1;\n      }\n\n      createAccountIfHasnt(address: Bytes): i32 {\n        let acctId = this.getAccountId(address);\n        if (acctId == -1){\n          this.accounts.push(new Account(address, new Bytes(0), [new Bytes(0)]));\n          return this.accounts.length - 1;\n        } else {\n          return acctId;\n        }\n      }\n  \n      account(address: Bytes): Account {\n          let id = this.getAccountId(address);\n          // require(id >= 0); // removed to avoid confusion\n          return this.accounts[id];\n      }\n\n      // setRawReceipts(rawreceipts: Bytes): void {\n      //   this.rawreceipts = rawreceipts\n      // }\n\n      // getRawReceipts(): Bytes {\n      //   return this.rawreceipts;\n      // }\n  }\n  ",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum-offchain.bytes/index.ts": "// each dsp should export zkmain_lib, asmain_lib, registerHandle. \n// should always use the same name, because will import like `import { registerHandle }  from xxx/dsp/ethereum_local/index`\nexport { zkmain_lib, asmain_lib } from \"./main\";\nexport { registerHandle } from \"./register\";\n// reuse ethereum dsp\nexport * from \"../ethereum/type\";",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum-offchain.bytes/main.ts": "import { Bytes } from \"../../common/type\";\nimport {\n  read_public_bytes_from_u64,\n  read_public_len_then_bytes,\n  read_private_len_then_bytes,\n  // @ts-ignore\n  require,\n} from \"../../common/zkwasm\";\nimport { handleFunc } from './register';\n\nimport { readBlocks } from \"../ethereum/readblock\";\n\nexport function zkmain_lib(): void {\n\n  let blocks = readBlocks();\n\n  const blockhash_latest = read_public_bytes_from_u64(32);\n\n  const offchain_data = read_private_len_then_bytes();\n\n  const expected_state = read_public_len_then_bytes();\n\n  const state: Bytes = handleFunc(blocks, offchain_data) as Bytes;\n\n  require(state == expected_state ? 1 : 0);\n}\n\nexport function asmain_lib(): Uint8Array {\n\n  let blocks = readBlocks();\n\n  const blockhash_latest = read_public_bytes_from_u64(32);\n\n  const offchain_data = read_private_len_then_bytes();\n\n  const state: Bytes = handleFunc(blocks, offchain_data) as Bytes;\n\n  return state as Uint8Array;\n}",
  "node_modules/@hyperoracle/zkgraph-lib/dsp/ethereum-offchain.bytes/register.ts": "import { Block } from \"../ethereum/type\";\nimport { Bytes } from \"../../common/type\";\n\n// export type HandleEvents = (events: Event[]) => Bytes\n\n// export let handleEvents: HandleEvents = () => {\n//   return new Bytes(0);\n// };\n\n// export function registerHandle1(handle: HandleEvents): void {\n//   handleEvents = handle\n// }\n\ntype HandleFunc = (blocks: Block[], data: Bytes) => Bytes\n\nexport let handleFunc: HandleFunc = () => {\n  return new Bytes(0);\n};\n\nexport function registerHandle(handle: HandleFunc): void {\n  handleFunc = handle\n}\n",
  "node_modules/@hyperoracle/zkgraph-lib/index.ts": "// for zkgraph dev user only\nexport * from \"./common/type\";\nexport { require } from \"./common/zkwasm\";\n// dsp specific types\nexport * from './dsp/ethereum/type';\n// export * from './dsp/ethereum_local/index';",
  "node_modules/@hyperoracle/zkgraph-lib/utils/conversion.ts": "// Implementation for\n// (https://github.com/graphprotocol/graph-tooling/blob/main/packages/ts/common/conversion.ts)\n// For The Graph, they appear to be implemented in the node\n// (https://github.com/graphprotocol/graph-node/blob/39094b1144b37f6614ca070c02ace2a0fd321391/runtime/wasm/src/module/mod.rs)\n// Need optimization for zkWASM\n// For this implementation, we use the `as-bigint` lib by Polywrap\n// (https://github.com/polywrap/as-bigint)\nimport { ByteArray } from \"../common/type\";\n// TODO: Remove third-party dependency\nexport function bytesToString(bytes: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < bytes.length; i++) {\n    str += String.fromCharCode(bytes[i]);\n  }\n  return str;\n}\n\nexport function bytesToHex(bytes: Uint8Array): string {\n  let hex = \"\";\n  for (let i = 0; i < bytes.length; i++) {\n    let byte = bytes[i].toString(16).padStart(2, \"0\");\n    hex += byte;\n  }\n  return \"0x\" + hex;\n}\n\nexport function stringToH160(s: string): Uint8Array {\n  assert(s.length == 40 || s.length == 42, \"address has wrong length\");\n  return ByteArray.fromHexString(s);\n}\n\n// For this implementation, we are referring to the `as-base58` lib by near\n// (https://github.com/near/as-base58)\nexport function bytesToBase58(n: Uint8Array): string {\n  const ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n  const BASE = 58;\n  const LEADER = ALPHABET.charAt(0);\n  const FACTOR_NUM = 406;\n  const FACTOR_DEN = 554;\n\n  const INV_FACTOR_NUM = FACTOR_DEN;\n  const INV_FACTOR_DEN = FACTOR_NUM - 1;\n\n  // Skip & count leading zeroes.\n  let pend = n.length;\n  let pbegin = 0;\n  while (pbegin != pend && n[pbegin] == 0) ++pbegin;\n  let zeroes = pbegin;\n\n  // Allocate enough space in big-endian base58 representation.\n  let size = ((pend - pbegin) * INV_FACTOR_NUM) / INV_FACTOR_DEN + 1;\n  let b58 = new Uint8Array(size);\n  let length = 0;\n\n  // Process the bytes.\n  while (pbegin != pend) {\n    let carry = u32(n[pbegin]);\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (let it = size - 1; it != -1 && (carry != 0 || i < length); --it, ++i) {\n      carry += u32(b58[it]) << 8;\n      b58[it] = carry % BASE;\n      carry = carry / BASE;\n    }\n    if (ASC_OPTIMIZE_LEVEL == 0) {\n      assert(!carry, \"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n\n  // Skip leading zeroes in base58 result.\n  let it = size - length;\n  while (it != size && b58[it] == 0) ++it;\n\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it < size; ++it) str += ALPHABET.charAt(b58[it]);\n  return str;\n}\n\n/**\n * Helper function to convert a BigInt to an ASBigInt for using `as-bigint` lib.\n * Convert Uint8Array to Uint32Array (with digit mask that restrict each element to be Uint28)\n */\nexport function uint8ArrayToUint32Array(\n  u8Array: Uint8Array,\n  littleEndian: bool = true,\n): Uint32Array {\n  let u8ArrayCopy: Uint8Array;\n\n  if (littleEndian) {\n    u8ArrayCopy = u8Array.slice();\n    u8ArrayCopy.reverse();\n  } else {\n    // trim leading zeros\n    let i: i32;\n    for (i = 0; i < u8Array.length; i++) {\n      if (u8Array[i] !== 0) {\n        break;\n      }\n    }\n    // if all zeros, return empty array\n    if (i === u8Array.length) {\n      return new Uint32Array(0);\n    }\n    u8ArrayCopy = u8Array.slice(i);\n  }\n\n  let hex = \"\";\n  for (let i = 0; i < u8ArrayCopy.length; i++) {\n    let byte = (u8ArrayCopy[i] < 16 ? \"0\" : \"\") + u8ArrayCopy[i].toString(16);\n    hex += byte;\n  }\n\n  const length = (hex.length + 6) / 7;\n  const u32Array = new Uint32Array(length);\n  for (let i = 0; i < length; i++) {\n    const firstIndex = hex.length - (i + 1) * 7;\n    const lastIndex = hex.length - i * 7;\n    // u32Array[i] = <u32>(\n    //   parseInt(hex.slice(firstIndex > 0 ? firstIndex : 0, lastIndex), 16)\n    // );\n    u32Array[i] = u32.parse(\n      hex.slice(firstIndex > 0 ? firstIndex : 0, lastIndex),\n      16,\n    );\n  }\n  return u32Array;\n}\n\n// TODO: depended by ByteArray.fromBigInt\n// export function uint32ArrayToUint8Array(u32Array: Uint32Array): Uint8Array {\n\n// }\n"
}