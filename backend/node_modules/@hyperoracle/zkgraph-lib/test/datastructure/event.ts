import { Bytes } from "../../common/type";
import { require } from "../../common/zkwasm";

export class Event {
    constructor(
        public address: Bytes,
        public esig: Bytes,
        public topic1: Bytes,
        public topic2: Bytes,
        public topic3: Bytes,
        public data: Bytes,
    ) {}
}

function genData(): Array<Event>{
    let addr1 = '0xa60ecf32309539dd84f27a9563754dca818b0001'
    // let e11 = new Event(Bytes.fromHexString(addr1), Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    // let e12 = new Event(Bytes.fromHexString(addr1), Bytes.fromHexString('0x1012'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let e11 = new Event(Bytes.fromHexString(addr1), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let e12 = new Event(Bytes.fromHexString(addr1), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let es1 = new Array<Event>(0);
    es1.push(e11)
    es1.push(e12)

    // let storage = new Map<Bytes, Bytes>()
    // storage.set(Bytes.fromHexString('0x1011'), Bytes.fromHexString('0x1012'))

    let addr2 = '0xdd84f27a9a60ecf32309539563754dca818b0002'
    let e21 = new Event(Bytes.fromHexString(addr2), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let e22 = new Event(Bytes.fromHexString(addr2), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    es1.push(e21)
    es1.push(e22)
    // let blocks = new Map<i64, BlockMutable>()
    // blocks.set(block1.number, block1)
    // blocks.set(block2.number, block2)

    // let addr1 = '0x0001'
    // let e11 = new Event(Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    // let e12 = new Event(Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())

    // let addr2 = '0x0002'
    // let e21 = new Event(Bytes.fromHexString('0x1021'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    // let e22 = new Event(Bytes.fromHexString('0x1022'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    return es1;
}

let addr = '0xa60ecf32309539dd84f27a9563754dca818b0001';
// let esig = Bytes.fromHexString('0x1012');
// let key = Bytes.fromHexString('0x5678');

function handleEvents(events: Event[]): Bytes{
    let i: i32;
    for (i = 0; i < events.length; i++){
        if (events[i].address == Bytes.fromHexString(addr)){
            break;
        }
    }
    return events[i].address;
    // console.log(blocks[1].account(addr).events[0].esig.toString());
    // blocks.get(-1).account(addr).storage.get(key);
}

export function zkmain(): void {
    let events = genData()
    let out = handleEvents(events)
    
    require(out == Bytes.fromHexString(addr));
}

//TODO:
// 1 map vs 2 map?
// - only 50 lines diff.
// what map code are in wat?
// mutable vs immutable?

//******************************** */

// export class AccountMutable {
//     public events = new Array<Event>(0)
//     public storage = new Map<Bytes, Bytes>()
//     constructor(
//         public address: Address,
//     ) {}

//     toImmutable(): Account {
//         return new Account(
//             StaticArray.fromArray(this.events),
//             this.storage, 
//             this.address
//         )
//     }
// }

// export class Block {
//     constructor(
//         public number: i64,
//         public events: StaticArray<Events>,
//         public accounts: StaticArray<Account>,
//         public accountId: Map<Address, i64> = new Map<Address, i64>()
//     ) {}

//     account(address: Address){
//         return this.accounts[this.accountId.get(address)];
//     }
// }



// TODO: string == string vs Bytes == Bytes