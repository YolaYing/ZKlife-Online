import { Bytes } from "../../common/type";
import { require } from "../../common/zkwasm";

export class Event {
    constructor(
        public address: Bytes,
        public esig: Bytes,
        public topic1: Bytes,
        public topic2: Bytes,
        public topic3: Bytes,
        public data: Bytes,
    ) {}
}

export class Account {
    constructor(
        public address: Bytes,
        public events: Array<Event>,
        // public storage: Map<Bytes, Bytes>,
    ) {}
}

class BlockMutable {
    public events: Event[] = new Array<Event>(0)
    public accounts: Account[] = new Array<Account>(0)
    // public accountId: Map<string, i32> = new Map<string, i32>()

    constructor(
        public number: i64,
    ) {}

    // addAccount(account: Bytes): void{
    //     // this.accountId.set(account.address, this.accounts.length);
    //     this.accounts.push(account);
    // }

    account(address: Bytes): Account{
        let i: i32;
        for (i = 0; i < this.accounts.length; i ++) {
            if (this.accounts[i].address == address){
                break;
            }
        }
        return this.accounts[i];
        // return this.accounts[this.accountId.get(address)];
    }
    // toImmutable(): Block {
    //     return new Block(
    //         this.number,
    //         StaticArray.fromArray(this.events),


    //     )
    // }
}


function genBlocks(): Array<BlockMutable>{
    let addr1 = '0xa60ecf32309539dd84f27a9563754dca818b0001'
    // let e11 = new Event(Bytes.fromHexString(addr1), Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    // let e12 = new Event(Bytes.fromHexString(addr1), Bytes.fromHexString('0x1012'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let e11 = new Event(Bytes.fromHexString(addr1), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let e12 = new Event(Bytes.fromHexString(addr1), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let es1 = new Array<Event>(0);
    es1.push(e11)
    es1.push(e12)

    // let storage = new Map<Bytes, Bytes>()
    // storage.set(Bytes.fromHexString('0x1011'), Bytes.fromHexString('0x1012'))

    let acct1 = new Account(
        Bytes.fromHexString(addr1),
        es1,
        // storage
        )

    let addr2 = '0xdd84f27a9a60ecf32309539563754dca818b0002'
    let e21 = new Event(Bytes.fromHexString(addr2), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let e22 = new Event(Bytes.fromHexString(addr2), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    let es2 = new Array<Event>(0);
    es2.push(e21)
    es2.push(e22)
    let acct2 = new Account(
        Bytes.fromHexString(addr2),
        es2,
        // storage,
        )
    
    let block1 = new BlockMutable(100)
    block1.accounts.push(acct1)
    block1.accounts.push(acct2)
    // block1.addAccount(acct1)
    // block1.addAccount(acct2)

    let block2 = new BlockMutable(101)
    block2.accounts.push(acct1)
    block2.accounts.push(acct2)
    // block2.addAccount(acct1)
    // block2.addAccount(acct2)

    let blocks = new Array<BlockMutable>(0)
    blocks.push(block1)
    blocks.push(block2)

    // let blocks = new Map<i64, BlockMutable>()
    // blocks.set(block1.number, block1)
    // blocks.set(block2.number, block2)

    // let addr1 = '0x0001'
    // let e11 = new Event(Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    // let e12 = new Event(Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())

    // let addr2 = '0x0002'
    // let e21 = new Event(Bytes.fromHexString('0x1021'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    // let e22 = new Event(Bytes.fromHexString('0x1022'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
    return blocks;
}

let addr = '0xa60ecf32309539dd84f27a9563754dca818b0001';
// let esig = Bytes.fromHexString('0x1012');
// let key = Bytes.fromHexString('0x5678');

function handleBlocks(blocks: BlockMutable[], latestBlockNum:i64): Bytes{
    return blocks[0].account(Bytes.fromHexString(addr)).events[0].address;
    // console.log(blocks[1].account(addr).events[0].esig.toString());
    // blocks.get(-1).account(addr).storage.get(key);
}

export function zkmain(): void {
    let blocks = genBlocks()
    let out = handleBlocks(blocks, 102)
    
    require(out == Bytes.fromHexString(addr));
}

//TODO:
// 1 map vs 2 map?
// - only 50 lines diff.
// what map code are in wat?
// mutable vs immutable?

//******************************** */

// export class AccountMutable {
//     public events = new Array<Event>(0)
//     public storage = new Map<Bytes, Bytes>()
//     constructor(
//         public address: Address,
//     ) {}

//     toImmutable(): Account {
//         return new Account(
//             StaticArray.fromArray(this.events),
//             this.storage, 
//             this.address
//         )
//     }
// }

// export class Block {
//     constructor(
//         public number: i64,
//         public events: StaticArray<Events>,
//         public accounts: StaticArray<Account>,
//         public accountId: Map<Address, i64> = new Map<Address, i64>()
//     ) {}

//     account(address: Address){
//         return this.accounts[this.accountId.get(address)];
//     }
// }



// TODO: string == string vs Bytes == Bytes