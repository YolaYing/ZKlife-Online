import { Bytes } from "../../../common/type";
import { read_public_len_then_bytes,
    read_private_len_then_bytes,
    wasm_private_input,
    // @ts-ignore
    require,
    read_private_bytes_from_u64,
    read_public_bytes_from_u64,
 } from "../../../common/zkwasm";


export class Event {
    constructor(
      public address: Bytes,
      public esig: Bytes,
      public topic1: Bytes,
      public topic2: Bytes,
      public topic3: Bytes,
      public data: Bytes,
    ) {}
}

class SlotRaw {
    constructor(
        public key: Bytes,
        public value: Bytes,
        public storageProof: Bytes,
    ) {}
}
  
  export class Account {
    public events: Event[] = new Array<Event>(0);
    public storage: Map<Bytes, Bytes> = new Map<Bytes, Bytes>();
    
    public storageRaw: SlotRaw[] = new Array<SlotRaw>(0);

      constructor(
          public address: Bytes,

          public rlpNode: Bytes,
          public accountProof: Bytes,
      ) {}
  }
  
  export class Block {
      public events: Event[] = new Array<Event>(0)
      public accounts: Account[] = new Array<Account>(0)
      public number: i64 = 0
  
      constructor(
          public rlpHeader: Bytes
      ) {}
  
      getAccountId(address: Bytes): i32 {
          let i: i32;
          for (i = 0; i < this.accounts.length; i ++) {
              if (this.accounts[i].address == address){
                  break;
              }
          }
          console.log('accoun1t: ')
          // DEBUG (norman): if you comment out the following 2, the error disappear. don't know reason.
          console.log('accoun1t1: ')
          console.log('accoun1t2: ')
        
          return i == this.accounts.length ? -1 : i;
      }
  
      hasAccount(address: Bytes): bool {
          return this.getAccountId(address) != -1;
      }
  
      account(address: Bytes): Account {
        console.log('account: '+this.accounts.length.toString())
          
          let id = this.getAccountId(address);
          require(id >= 0);
          return this.accounts[id];
      }
  }
  
// function genBlocks(): Array<Block>{
//     let addr1 = '0xa60ecf32309539dd84f27a9563754dca818b0001'
//     // let e11 = new Event(Bytes.fromHexString(addr1), Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     // let e12 = new Event(Bytes.fromHexString(addr1), Bytes.fromHexString('0x1012'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     let e11 = new Event(Bytes.fromHexString(addr1), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     let e12 = new Event(Bytes.fromHexString(addr1), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     let es1 = new Array<Event>(0);
//     es1.push(e11)
//     es1.push(e12)

//     let storage = new Map<Bytes, Bytes>()
//     storage.set(Bytes.fromHexString('0x1011'), Bytes.fromHexString('0x1012'))

//     let acct1 = new Account(
//         Bytes.fromHexString(addr1),
//         es1,
//         storage
//         )

//     let addr2 = '0xdd84f27a9a60ecf32309539563754dca818b0002'
//     let e21 = new Event(Bytes.fromHexString(addr2), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     let e22 = new Event(Bytes.fromHexString(addr2), Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     let es2 = new Array<Event>(0);
//     es2.push(e21)
//     es2.push(e22)
//     let acct2 = new Account(
//         Bytes.fromHexString(addr2),
//         es2,
//         storage,
//         )
    
//     let block1 = new Block(100)
//     block1.accounts.push(acct1)
//     block1.accounts.push(acct2)
//     // block1.addAccount(acct1)
//     // block1.addAccount(acct2)

//     let block2 = new Block(101)
//     block2.accounts.push(acct1)
//     block2.accounts.push(acct2)
//     // block2.addAccount(acct1)
//     // block2.addAccount(acct2)

//     let blocks = new Array<Block>(0)
//     blocks.push(block1)
//     blocks.push(block2)

//     // let blocks = new Map<i64, BlockMutable>()
//     // blocks.set(block1.number, block1)
//     // blocks.set(block2.number, block2)

//     // let addr1 = '0x0001'
//     // let e11 = new Event(Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     // let e12 = new Event(Bytes.fromHexString('0x1011'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())

//     // let addr2 = '0x0002'
//     // let e21 = new Event(Bytes.fromHexString('0x1021'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     // let e22 = new Event(Bytes.fromHexString('0x1022'),Bytes.empty(),Bytes.empty(),Bytes.empty(),Bytes.empty())
//     return blocks;
// }


// - private
//     - [multi] rlp(blockheader),
//         - [multi] address, rlp(bal, nonce, storage root, codehash), account proof,
//             - [multi] key, value, storage proof
// - public
//     - zkgstate, blockhash_latest (get from onchain by `blocknum`)

export function zkmain(): void {
    const blockCount: i32 = wasm_private_input() as i32;
    console.log('blockCount ' + blockCount.toString())
    
    let blocks = new Array<Block>(0);
    for (let i = 0; i < blockCount; i++){
        let rlpHeader = read_private_len_then_bytes()
        console.log('rlpHeader ' + rlpHeader.toHexString())
    
        let block = new Block(rlpHeader);
        
        let accountCount: i32 = wasm_private_input() as i32;
        console.log('accountCount ' + accountCount.toString())
        for (let j = 0; j < accountCount; j++){
            let address = read_private_bytes_from_u64(20);
            console.log('address ' + address.toHexString())
            let rlpNode = read_private_len_then_bytes();
            console.log('rlpNode ' + rlpNode.toHexString())
            let accountProof = read_private_len_then_bytes();
            let account = new Account(address, rlpNode, accountProof);

            let slotCount: i32 = wasm_private_input() as i32;
            console.log('slotCount ' + slotCount.toString())
            for (let k = 0; k < slotCount; k++){
                let key = read_private_bytes_from_u64(32);
                let value = read_private_bytes_from_u64(32);
                let storageProof = read_private_len_then_bytes();
                console.log('key ' + key.toHexString())
                console.log('value ' + value.toHexString())
                console.log('storageProof ' + storageProof.toHexString())
                account.storage.set(key, value)
            }

            block.accounts.push(account)
        }
        blocks.push(block);
    }

    const expected_state = read_public_len_then_bytes();
    console.log('expected_state ' + expected_state.toHexString())
    const blockhash_latest = read_public_bytes_from_u64(32);
    console.log('blockhash_latest ' + blockhash_latest.toHexString())
    
    const state: Bytes = handleBlocks(blocks) as Bytes;
  
    require(state == expected_state ? 1 : 0);
  }

// export function zkmain(): void {
//     let blocks = genBlocks()
//     let out = handleBlocks(blocks, 102)
    
//     require(out == Bytes.fromHexString(addr));
// }

let addr = '0xa60ecf32309539dd84f27a9563754dca818b0001';
// let esig = Bytes.fromHexString('0x1012');
// let key = Bytes.fromHexString('0x5678');

function handleBlocks(blocks: Block[]): Bytes{
    console.log('here0 '+blocks.length.toString())
    blocks[0].account(Bytes.fromHexString(addr));
    console.log('here')
    return blocks[0].account(Bytes.fromHexString(addr)).storage.get(Bytes.fromHexString('0x0000000000000000000000000000000000000000000000000000000000000008'));
    // console.log(blocks[1].account(addr).events[0].esig.toString());
    // blocks.get(-1).account(addr).storage.get(key);
}

//TODO:
// done 1 map vs 2 map?
// - only 50 lines diff.
// done what map code are in wat?
// - sets & gets
// ~ 400 loc, acceptable
// mutable vs immutable?

//******************************** */

// export class AccountMutable {
//     public events = new Array<Event>(0)
//     public storage = new Map<Bytes, Bytes>()
//     constructor(
//         public address: Address,
//     ) {}

//     toImmutable(): Account {
//         return new Account(
//             StaticArray.fromArray(this.events),
//             this.storage, 
//             this.address
//         )
//     }
// }

// export class Block {
//     constructor(
//         public number: i64,
//         public events: StaticArray<Events>,
//         public accounts: StaticArray<Account>,
//         public accountId: Map<Address, i64> = new Map<Address, i64>()
//     ) {}

//     account(address: Address){
//         return this.accounts[this.accountId.get(address)];
//     }
// }



// done TODO: string == string vs Bytes == Bytes
// Bytes == Bytes is cheaper
// 

//TODO: add a zkmain for state
// how to hide something in compiler?
