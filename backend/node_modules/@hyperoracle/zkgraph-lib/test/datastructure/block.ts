import { Bytes, Event, Slot, Account, Block } from "../../common/type";
import { read_public_len_then_bytes,
    read_private_len_then_bytes,
    wasm_private_input,
    // @ts-ignore
    require,
    read_private_bytes_from_u64,
    read_public_bytes_from_u64,
    read_private_array_of_len_then_bytes,
 } from "../../common/zkwasm";

export function zkmain(): void {
    const blockCount: i32 = wasm_private_input() as i32;
    // console.log('blockCount ' + blockCount.toString())
    
    let blocks = new Array<Block>(0);
    for (let i = 0; i < blockCount; i++){
        let rlpHeader = read_private_len_then_bytes()
        // console.log('rlpHeader ' + rlpHeader.toHexString())
    
        let block = new Block(rlpHeader);
        
        let accountCount: i32 = wasm_private_input() as i32;
        // console.log('accountCount ' + accountCount.toString())
        for (let j = 0; j < accountCount; j++){
            let address = read_private_bytes_from_u64(20);
            // console.log('address ' + address.toHexString())
            let rlpNode = read_private_len_then_bytes();
            // console.log('rlpNode ' + rlpNode.toHexString())
            let accountProof = read_private_array_of_len_then_bytes();

            // console.log('accountProof: ' + accountProof.length.toString())
            // console.log('accountProof[-1]: ' + accountProof[accountProof.length-1].toHexString())
            let account = new Account(address, rlpNode, accountProof);

            let slotCount: i32 = wasm_private_input() as i32;
            // console.log('slotCount ' + slotCount.toString())
            for (let k = 0; k < slotCount; k++){
                let key = read_private_bytes_from_u64(32);
                // let key = wasm_private_input() as i32;
                let value = read_private_len_then_bytes();
                let storageProof = read_private_array_of_len_then_bytes();
                // console.log('storageProof: ' + storageProof.length.toString())
                // console.log('storageProof[-1]: ' + storageProof[storageProof.length-1].toHexString())
            
                // console.log('key ' + key.toHexString())
                // console.log('value ' + value.toHexString())
                // console.log('storageProof ' + storageProof.toHexString())

                account.slots.push(new Slot(key, value, storageProof))
            }

            block.accounts.push(account)
        }
        blocks.push(block);
    }

    const expected_state = read_public_len_then_bytes();
    // console.log('expected_state ' + expected_state.toHexString())
    const blockhash_latest = read_public_bytes_from_u64(32);
    // console.log('blockhash_latest ' + blockhash_latest.toHexString())
    
    const state: Bytes = handleBlocks(blocks) as Bytes;
  
    require(state == expected_state ? 1 : 0);
}

let addr = '0xa60ecf32309539dd84f27a9563754dca818b815e';
// let esig = Bytes.fromHexString('0x1012');
let key = Bytes.fromHexString('0x0000000000000000000000000000000000000000000000000000000000000008');
// let key = 8;

function handleBlocks(blocks: Block[]): Bytes{
    // console.log('here0')
    // let acct = blocks[0].account(Bytes.fromHexString(addr));
    // console.log('here1 ' + acct.hasSlotByBytes(key).toString())
    return blocks[0].account(Bytes.fromHexString(addr)).storage(key);
    // return blocks[0].account(Bytes.fromHexString(addr)).storageByBytes(key);
    // console.log(blocks[1].account(addr).events[0].esig.toString());
    // blocks.get(-1).account(addr).storage.get(key);
}