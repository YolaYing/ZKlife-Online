import {
  wasm_private_input,
  read_private_bytes_from_u64,
  read_private_len_then_bytes,
  read_private_array_of_len_then_bytes,
} from "../../common/zkwasm";
import { U256_LEN, MAX_EVENTS, MAX_BLOCK_LENGTH } from "../../common/constants";
import { packMatchedEvents } from "./packevents";
import { Block, Slot, Account } from "./type";

declare function matchEventsOnRLP(stream: usize, len: u32, retMatchEvents: usize): u32;
declare function constraintsEvent(blockhash: usize, blocknumber: u32, receiptroot: usize): boolean;


// @ts-ignore
@external("env", "wasm_write_context")
export declare function wasm_write_context(v: u64): void

export function readBlocks(): Array<Block> {
  const blockCount: i32 = wasm_private_input() as i32;

  //TODO: assert block count <= MAX_BLOCK_LENGTH

  let blocks = new Array<Block>(0);
  for (let i = 0; i < blockCount; i++){
      let blockNumber = wasm_private_input();
      let rlpHeader = read_private_len_then_bytes();
      // for batch
      wasm_write_context(blockNumber);
      
      let block = new Block(rlpHeader, blockNumber);

      let accountCount: i32 = wasm_private_input() as i32;
      for (let j = 0; j < accountCount; j++){
          let address = read_private_bytes_from_u64(20);
          let rlpNode = read_private_len_then_bytes();
          let accountProof = read_private_array_of_len_then_bytes();
          let account = new Account(address, rlpNode, accountProof);

          let slotCount: i32 = wasm_private_input() as i32;
          for (let k = 0; k < slotCount; k++){
              let key = read_private_bytes_from_u64(32);
              let value = read_private_len_then_bytes();
              let storageProof = read_private_array_of_len_then_bytes();

              account.slots.push(new Slot(key, value, storageProof))
          }

          block.accounts.push(account)
      }

      // Reading rlp(receipt)s. 
      let receiptscount: i32 = wasm_private_input() as i32;
      if (receiptscount > 0) {
        let rawreceipts = read_private_len_then_bytes();

        // Call c for match events
        let matchedEventOffsets = new Uint32Array(MAX_EVENTS * 7); // TODO: u32?
        let matchedEventCnt = matchEventsOnRLP(rawreceipts.dataStart, rawreceipts.length, matchedEventOffsets.dataStart);

        // Pack match offsets to Event[]
        let events = packMatchedEvents(
          rawreceipts.dataStart,
          matchedEventCnt,
          matchedEventOffsets.dataStart,
        );
          
        // Add Events to block
        block.setEvents(events)
      }

      blocks.push(block);
  }

  // padding to MAX_BLOCK_LENGTH, required by the batcher
  if (blockCount < MAX_BLOCK_LENGTH) {
    for(let i = blockCount; i < MAX_BLOCK_LENGTH; i ++ ) {
      wasm_write_context(blocks[blockCount-1].number);
    }
  }

  return blocks;
}