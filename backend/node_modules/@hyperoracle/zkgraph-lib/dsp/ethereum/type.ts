//@ts-ignore
import { require } from "../../common/zkwasm";
import { Bytes } from "../../common/types/bytes";

export class Event {
    constructor(
      public address: Bytes,
      public esig: Bytes,
      public topic1: Bytes,
      public topic2: Bytes,
      public topic3: Bytes,
      public data: Bytes,
    ) {}
}

export class Slot {
    constructor(
        public key: Bytes,
        public value: Bytes,
        public storageProof: Bytes[],
    ) {}
}
  export class Account {
    public events: Event[] = new Array<Event>(0);
    public slots: Slot[] = new Array<Slot>(0);

    constructor(
        public address: Bytes,

        public rlpNode: Bytes,
        public accountProof: Bytes[],
    ) {}
    //TODO: order / uniqueness
    getSlotId(key: Bytes): i32 {
        let i: i32;

        for (i = 0; i < this.slots.length; i ++) {
            if (this.slots[i].key == key){
                break;
            }
        }
        return i == this.slots.length ? -1 : i;
    }

    hasSlot(key: Bytes): bool {
        return this.getSlotId(key) != -1;
    }

    storage(key: Bytes): Bytes {
        let id = this.getSlotId(key);
        // require(id >= 0); // removed to avoid confusion
        return this.slots[id].value;
    }

    eventsByEsig(esig: Bytes): Event[] {
      let es = new Array<Event>(0);

      for (let i = 0; i < this.events.length; i ++) {
          if (this.events[i].esig == esig){
              es.push(this.events[i])
          }
      }
      return es;
    }

  }
  
  export class Block {
      public events: Event[] = new Array<Event>(0)
      public accounts: Account[] = new Array<Account>(0)
      // public number: i64 = 0
      // private rawreceipts: Bytes = new Bytes(0)
  
      constructor(
        public rlpHeader: Bytes,
        public number: i64
      ) {}

      addEvent(event: Event): void {
        this.events.push(event);
        let acctId = this.createAccountIfHasnt(event.address);
        this.accounts[acctId].events.push(event);
      }

      setEvents(events: Event[]): void {
        this.events = events;
        // only ~150 lines of wat
        for (let i = 0; i < events.length; i++){
          let acctId = this.createAccountIfHasnt(events[i].address);
          this.accounts[acctId].events.push(events[i]);
        }
      }
  
      getAccountId(address: Bytes): i32 {
          let i: i32;
          for (i = 0; i < this.accounts.length; i ++) {
              if (this.accounts[i].address == address){
                  break;
              }
          }
          return i == this.accounts.length ? -1 : i;
      }
  
      hasAccount(address: Bytes): bool {
          return this.getAccountId(address) != -1;
      }

      createAccountIfHasnt(address: Bytes): i32 {
        let acctId = this.getAccountId(address);
        if (acctId == -1){
          this.accounts.push(new Account(address, new Bytes(0), [new Bytes(0)]));
          return this.accounts.length - 1;
        } else {
          return acctId;
        }
      }
  
      account(address: Bytes): Account {
          let id = this.getAccountId(address);
          // require(id >= 0); // removed to avoid confusion
          return this.accounts[id];
      }

      // setRawReceipts(rawreceipts: Bytes): void {
      //   this.rawreceipts = rawreceipts
      // }

      // getRawReceipts(): Bytes {
      //   return this.rawreceipts;
      // }
  }
  