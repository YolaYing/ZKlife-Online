'use strict';

var BN = require('bn.js');
var ethers = require('ethers');
var rlp = require('@ethereumjs/rlp');
var utils$2 = require('@murongg/utils');
var assert = require('assert');
var os = require('os');
var path = require('path');
var fs = require('fs');
var yaml = require('js-yaml');
var semver = require('semver');
var zkwasmServiceHelper = require('@hyperoracle/zkwasm-service-helper');
var axios = require('axios');
var FormData = require('form-data');
var Web3EthContract = require('web3-eth-contract');
var axiosRetry = require('axios-retry');

const networks = [
  {
    name: "Sepolia",
    label: "Sepolia",
    value: 11155111,
    expectedEth: 2e-3,
    hex: "0xaa36a7"
  },
  {
    name: "Goerli",
    label: "Goerli",
    value: 5,
    expectedEth: 0.5,
    hex: "0x5"
  },
  {
    name: "Mainnet",
    label: "Mainnet",
    value: 1
  }
];
const AggregatorVerifierABI = {
  contractName: "AggregatorVerifier",
  abi: [
    {
      inputs: [
        {
          internalType: "contract AggregatorVerifierCoreStep[]",
          name: "_steps",
          type: "address[]"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [
        {
          internalType: "uint256[]",
          name: "proof",
          type: "uint256[]"
        },
        {
          internalType: "uint256[]",
          name: "verify_instance",
          type: "uint256[]"
        },
        {
          internalType: "uint256[]",
          name: "aux",
          type: "uint256[]"
        },
        {
          internalType: "uint256[][]",
          name: "target_instance",
          type: "uint256[][]"
        }
      ],
      name: "verify",
      outputs: [],
      stateMutability: "view",
      type: "function",
      constant: true
    }
  ]
};
const graph_abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_bountyToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_bountyReward",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_verifier",
        type: "address"
      },
      {
        internalType: "address",
        name: "_destAddr",
        type: "address"
      },
      {
        internalType: "string",
        name: "_graphURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "zkgState",
        type: "bytes"
      }
    ],
    name: "Trigger",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldReward",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newReward",
        type: "uint256"
      }
    ],
    name: "UpdateReward",
    type: "event"
  },
  {
    inputs: [],
    name: "bountyReward",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "bountyToken",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "destAddr",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "zkgState",
        type: "bytes"
      }
    ],
    name: "encodePublicInput",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "graphURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "zkgState",
        type: "bytes"
      },
      {
        internalType: "uint256[]",
        name: "proof",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "verify_instance",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "aux",
        type: "uint256[]"
      }
    ],
    name: "trigger",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "updateReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "verifier",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "zkgState",
        type: "bytes"
      },
      {
        internalType: "uint256[]",
        name: "proof",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "verify_instance",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "aux",
        type: "uint256[]"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const addressFactory = {
  mainnet: "not support yet",
  sepolia: "0xE484E5B8b71aA7955d1De4D52737BF436eBf9970",
  goerli: "not support yet"
};
const abiFactory = [
  "function getAllZkg() external view returns (address[] memory)",
  "function registry(address destAddr, address bountyToken, uint256 bountyReward, bytes32 dspID, string memory graphURI, uint256 pointX, uint256 pointY) external returns (address graph)",
  "function getGraphBycreator(address creator) external view returns (address[] memory)",
  "function getGraphInfoByAddress(address graph) external view returns (address creator, uint256 bountyReward, address verifier, string memory graphURI)"
];
const AggregatorVerifierAddress = {
  mainnet: "not support yet",
  sepolia: "0x714C66711F6552D4F388Ec79D4A33FE20173cC34",
  goerli: "0x5e6ca2dd26eA8F9A17aEc6e35a8dcD7C5B12FcDF"
};
const AddressZero = "0x0000000000000000000000000000000000000000";

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AddressZero: AddressZero,
  AggregatorVerifierABI: AggregatorVerifierABI,
  AggregatorVerifierAddress: AggregatorVerifierAddress,
  abiFactory: abiFactory,
  addressFactory: addressFactory,
  graph_abi: graph_abi,
  networks: networks
});

function fromHexString(hexString) {
  hexString = hexString.startsWith("0x") ? hexString.slice(2) : hexString;
  hexString = hexString.length % 2 ? `0${hexString}` : hexString;
  return Uint8Array.from(Buffer.from(hexString, "hex"));
}
function toHexString(bytes) {
  return Buffer.from(bytes).toString("hex");
}
function toHexStringBytes32Reverse(arr) {
  let result = "";
  for (let i = 0; i < arr.length / 32; i++) {
    result += `0x${toHexString(arr.slice(i * 32, (i + 1) * 32).reverse())}
`;
  }
  return result;
}
function areEqualArrays(first, second) {
  return first.length === second.length && first.every((value, index) => value === second[index]);
}
function trimPrefix(str, prefix) {
  if (str.startsWith(prefix))
    str = str.substring(prefix.length);
  return str;
}
function concatHexStrings(hexStrings) {
  let result = "";
  for (const hexString of hexStrings)
    result += hexString.startsWith("0x") ? hexString.slice(2) : hexString;
  return `0x${result}`;
}
function hexToBNs(hexString) {
  const bytes = new Array(Math.ceil(hexString.length / 16));
  for (let i = 0; i < hexString.length; i += 16)
    bytes[i] = new BN(hexString.slice(i, Math.min(i + 16, hexString.length)), 16, "le");
  return bytes;
}
function parseArg(input) {
  const inputArray = input.split(":");
  const value = inputArray[0];
  const type = inputArray[1];
  const re1 = /^[0-9A-Fa-f]+$/;
  const re2 = /^\d+$/;
  if (!(re1.test(value.slice(2)) || re2.test(value))) {
    console.log("Error: input value is not an interger number");
    return null;
  }
  if (type === "i64") {
    let v;
    if (value.slice(0, 2) === "0x")
      v = new BN(value.slice(2), 16);
    else
      v = new BN(value);
    return [v];
  } else if (type === "bytes" || type === "bytes-packed") {
    if (value.slice(0, 2) !== "0x") {
      console.log("Error: bytes input need start with 0x");
      return null;
    }
    const bytes = hexToBNs(value.slice(2));
    return bytes;
  } else {
    console.log("Unsupported input data type: %s", type);
    return null;
  }
}
function parseArgs(raw) {
  const parsedInputs = [];
  for (let input of raw) {
    input = input.trim();
    if (input !== "") {
      const args = parseArg(input);
      if (args != null)
        parsedInputs.push(args);
      else
        throw new Error(`invalid args in ${input}`);
    }
  }
  return parsedInputs.flat();
}
function getTargetNetwork(inputtedNetworkName) {
  const validNetworkNames = networks.map((net) => net.name.toLowerCase());
  if (!validNetworkNames.includes(inputtedNetworkName.toLowerCase())) {
    return;
  }
  const targetNetwork = networks.find(
    (net) => net.name.toLowerCase() === inputtedNetworkName.toLowerCase()
  );
  return targetNetwork;
}
function dspParamsNormalize(paramNames = [], paramKeyValue = {}) {
  const params = {};
  paramNames.forEach((param) => {
    Reflect.set(params, param, paramKeyValue[param]);
  });
  return params;
}
function isNumber(value) {
  return typeof value === "number" && isFinite(value) || !isNaN(Number(value));
}
function loadConfigByNetwork(yaml, networksConfig, isDataSource) {
  var _a, _b, _c;
  let network;
  if (((_a = yaml.dataSources) == null ? void 0 : _a[0].kind) !== "ethereum")
    throw new Error("loadConfigByNetwork only support ethereum right now.");
  if (isDataSource)
    network = (_b = yaml.dataSources) == null ? void 0 : _b[0].network;
  else
    network = (_c = yaml.dataDestinations) == null ? void 0 : _c[0].network;
  if (!network) {
    throw new Error(
      `Network of "${isDataSource ? "dataSource" : "dataDestination"}" is not defined in yaml.`
    );
  }
  const targetConfig = networksConfig ? networksConfig[network] : void 0;
  if (!targetConfig) {
    throw new Error(
      `[-] networksConfig for network "${network}" is not found in zkgraph-api.`
    );
  }
  return targetConfig;
}

var utils$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  areEqualArrays: areEqualArrays,
  concatHexStrings: concatHexStrings,
  dspParamsNormalize: dspParamsNormalize,
  fromHexString: fromHexString,
  getTargetNetwork: getTargetNetwork,
  isNumber: isNumber,
  loadConfigByNetwork: loadConfigByNetwork,
  parseArgs: parseArgs,
  toHexString: toHexString,
  toHexStringBytes32Reverse: toHexStringBytes32Reverse,
  trimPrefix: trimPrefix
});

class Input {
  inputStr = ["", ""];
  static privateId = 0;
  static publicId = 1;
  getPrivateInputStr() {
    return this.inputStr[Input.privateId];
  }
  getPublicInputStr() {
    return this.inputStr[Input.publicId];
  }
  formatIntInput(input) {
    return `0x${input.toString(16)}:i64 `;
  }
  formatHexStringInput(input) {
    return `0x${trimPrefix(input, "0x")}:bytes-packed `;
  }
  formatVarLenInput(input) {
    const inp = trimPrefix(input, "0x");
    const formatted = `${this.formatIntInput(
      Math.ceil(inp.length / 2)
    )}${this.formatHexStringInput(inp)}`;
    return formatted;
  }
  addInt(input, isPublic = false) {
    this.inputStr[isPublic ? Input.publicId : Input.privateId] += this.formatIntInput(input);
  }
  addHexString(input, isPublic = false) {
    this.inputStr[isPublic ? Input.publicId : Input.privateId] += this.formatHexStringInput(input);
  }
  addVarLenHexString(input, isPublic = false) {
    this.inputStr[isPublic ? Input.publicId : Input.privateId] += this.formatVarLenInput(input);
  }
  // ['0xaa', '0xbbbb', '0xcccccc']
  addVarLenHexStringArray(input, isPublic = false) {
    this.inputStr[isPublic ? Input.publicId : Input.privateId] += this.formatIntInput(input.length);
    for (let i = 0; i < input.length; i++)
      this.inputStr[isPublic ? Input.publicId : Input.privateId] += this.formatVarLenInput(input[i]);
  }
}

class DataPrep {
}
class DataSourcePlugin {
  toExecParams(params) {
    return dspParamsNormalize(this.execParams, params);
  }
  toProveParams(params) {
    return dspParamsNormalize(this.proveParams, params);
  }
  toPrepareParamsFromExecParams(execParams) {
    return this.toPrepareParams(execParams, "exec");
  }
  toPrepareParamsFromProveParams(proveParams) {
    return this.toPrepareParams(proveParams, "prove");
  }
}

class ZKGraphRequireFailed extends Error {
  constructor(message) {
    super(message);
  }
}
class ImageAlreadyExists extends Error {
  constructor(message) {
    super(message);
  }
}
class ProveTaskNotReady extends Error {
  constructor(message) {
    super(message);
  }
}
class PaymentError extends Error {
  constructor(message) {
    super(message);
  }
}
class YamlInvalidFormat extends Error {
  constructor(message) {
    super(message);
  }
}
class YamlHealthCheckFailed extends Error {
  constructor(message) {
    super(message);
  }
}
class YamlNotSupported extends Error {
  constructor(message) {
    super(message);
  }
}
class TDNoTaskFound extends Error {
  constructor(message) {
    super(message);
  }
}
class GraphAlreadyExist extends Error {
  constructor(message) {
    super(message);
  }
}
class DSPNotFound extends Error {
  constructor(message) {
    super(message);
  }
}
class BlockNotFound extends Error {
  constructor(message) {
    super(message);
  }
}
class OldBlockNumber extends Error {
  constructor(message) {
    super(message);
  }
}

var error = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BlockNotFound: BlockNotFound,
  DSPNotFound: DSPNotFound,
  GraphAlreadyExist: GraphAlreadyExist,
  ImageAlreadyExists: ImageAlreadyExists,
  OldBlockNumber: OldBlockNumber,
  PaymentError: PaymentError,
  ProveTaskNotReady: ProveTaskNotReady,
  TDNoTaskFound: TDNoTaskFound,
  YamlHealthCheckFailed: YamlHealthCheckFailed,
  YamlInvalidFormat: YamlInvalidFormat,
  YamlNotSupported: YamlNotSupported,
  ZKGraphRequireFailed: ZKGraphRequireFailed
});

async function getRawLogsFromBlockReceipts(ethersProvider, blockNumber, ignoreFailedTx) {
  const blockReceipts = await ethersProvider.send("eth_getBlockReceipts", [blockNumber]);
  if (blockReceipts == null)
    throw new Error("[-] Can't get block receipts, please make sure blocknum is valid");
  const rawReceipt = [];
  for (const receipt of blockReceipts) {
    if (ignoreFailedTx && receipt.status !== "0x1")
      continue;
    const txRawLogs = [];
    const txRawReceipt = [receipt.status, receipt.cumulativeGasUsed, receipt.logsBloom];
    const logs = receipt.logs;
    for (const log of logs)
      txRawLogs.push([log.address, log.topics, log.data]);
    txRawReceipt.push(txRawLogs);
    rawReceipt.push(`0x${Buffer.from(rlp.RLP.encode(txRawReceipt)).toString("hex")}`);
  }
  return rawReceipt;
}
async function getRawLogsFromTxsReceipt(ethersProvider, blockNumber, ignoreFailedTx) {
  const block = await ethersProvider.getBlock(blockNumber);
  const rawReceipt = [];
  for (const txHash of block.transactions) {
    const receipt = await ethersProvider.getTransactionReceipt(txHash);
    if (ignoreFailedTx && receipt.status !== 1)
      continue;
    if (receipt.status === void 0)
      throw new Error("[-] Can't get tx status, please make sure provider is enabled Byzantium.");
    const txRawLogs = [];
    const txRawReceipt = [`0x${receipt.status.toString(16)}`, `0x${receipt.cumulativeGasUsed.toNumber().toString(16)}`, receipt.logsBloom];
    const logs = receipt.logs;
    for (const log of logs)
      txRawLogs.push([log.address, log.topics, log.data]);
    txRawReceipt.push(txRawLogs);
    rawReceipt.push(`0x${Buffer.from(rlp.RLP.encode(txRawReceipt)).toString("hex")}`);
  }
  return rawReceipt;
}
async function getRawReceiptsWithoutDebugRPC(ethersProvider, blockid, ignoreFailedTx = false) {
  if (Number.isFinite(blockid))
    blockid = ethers.ethers.utils.hexValue(blockid);
  try {
    return await getRawLogsFromBlockReceipts(ethersProvider, blockid, ignoreFailedTx);
  } catch {
    console.warn("The RPC does not support erigon rpc, fetching data may be slow");
    return await getRawLogsFromTxsReceipt(ethersProvider, blockid, ignoreFailedTx);
  }
}
async function getRawReceiptsWithDebugRPC(ethersProvider, blockid) {
  if (Number.isFinite(blockid))
    blockid = ethers.ethers.utils.hexValue(blockid);
  return ethersProvider.send("debug_getRawReceipts", [blockid]);
}
async function getRawReceipts(ethersProvider, blockid, useDebugRPC = false) {
  if (useDebugRPC)
    return await getRawReceiptsWithDebugRPC(ethersProvider, blockid);
  else
    return await getRawReceiptsWithoutDebugRPC(ethersProvider, blockid, false);
}
async function getBlockBasic(provider, block, type) {
  const fn = async () => {
    const fullBlock = await provider.send(type === "hash" ? "eth_getBlockByHash" : "eth_getBlockByNumber", [
      type === "hash" ? block : ethers.ethers.utils.hexValue(block),
      false
    ]);
    return fullBlock;
  };
  const result = await utils$2.retry(fn, 3);
  if (result === null)
    throw new BlockNotFound(`Not found block ${block} in this provider: ${provider.connection.url}`);
  else
    return result;
}
async function getBlockByNumber(ethersProvider, blockNumber) {
  return await getBlockBasic(ethersProvider, blockNumber, "number");
}
async function getBlockByHash(ethersProvider, blockHash) {
  return await getBlockBasic(ethersProvider, blockHash, "hash");
}
async function getBlock(ethersProvider, blockid) {
  if (typeof blockid === "string" && blockid.length === 66 && blockid.charAt(0) === "0" && blockid.charAt(1) === "x") {
    return await getBlockByHash(ethersProvider, blockid).catch((error) => {
      throw error;
    });
  } else if (utils$2.isMaybeNumber(blockid)) {
    return await getBlockByNumber(ethersProvider, utils$2.toNumber(blockid)).catch((error) => {
      throw error;
    });
  } else {
    throw new Error("please provide a valid block number.");
  }
}
async function getProof(ethersProvider, address, keys, blockid) {
  var _a;
  try {
    return await ethersProvider.send("eth_getProof", [address, keys, blockid]);
  } catch (error) {
    if ((_a = error == null ? void 0 : error.body) == null ? void 0 : _a.includes("requested block is too old")) {
      const body = JSON.parse(error.body);
      throw new OldBlockNumber(body.error.message);
    } else {
      throw error;
    }
  }
}

function logLoadingAnimation() {
  const width = Math.min(process.stdout.columns - 4, 55);
  let frame = 0;
  let stop = false;
  const frames = ["\u2593"];
  let position = 0;
  const intervalId = setInterval(() => {
    if (stop) {
      clearInterval(intervalId);
      process.stdout.clearLine();
      process.stdout.cursorTo(0);
      return;
    }
    const currentFrame = frames[frame % frames.length];
    const loadingBar = `[*] ${currentFrame.repeat(
      position
    )}\u2592${currentFrame.repeat(width - position - 1)}`;
    process.stdout.cursorTo(0);
    process.stdout.write(loadingBar);
    position = (position + 1) % width;
    frame++;
  }, 400);
  return {
    stopAndClear: () => {
      stop = true;
      process.stdout.clearLine();
      process.stdout.cursorTo(0);
    }
  };
}
function logReceiptAndEvents(rawreceiptList, matchedEventOffsets, filteredEventList) {
  console.log(
    "[*]",
    rawreceiptList.length,
    rawreceiptList.length > 1 ? "receipts fetched" : "receipt fetched"
  );
  console.log(
    "[*]",
    matchedEventOffsets.length / 7,
    matchedEventOffsets.length / 7 > 1 ? "events matched" : "event matched"
  );
  for (const i in filteredEventList) {
    for (const j in filteredEventList[i]) {
      filteredEventList[i][j].prettyPrint(
        `	Tx[${i}]Event[${j}]`,
        false
      );
    }
  }
}

class Event {
  address;
  topics;
  data;
  address_offset;
  topics_offset;
  data_offset;
  constructor(address, topics, data, address_offset, topics_offset, data_offset) {
    this.address = address;
    this.topics = topics;
    this.data = data;
    this.address_offset = address_offset;
    this.topics_offset = topics_offset;
    this.data_offset = data_offset;
  }
  prettyPrint(prefix = "", withoffsets = true) {
    console.log(
      prefix,
      "|--addr :",
      toHexString(this.address),
      withoffsets ? this.address_offset : ""
    );
    for (let j = 0; j < this.topics.length; j++) {
      console.log(
        prefix,
        `|--arg#${j.toString()}: ${toHexString(this.topics[j])}`,
        withoffsets ? this.topics_offset[j] : ""
      );
    }
    console.log(
      prefix,
      "|--data :",
      toHexString(this.data),
      withoffsets ? this.data_offset : ""
    );
    console.log("");
  }
  match(wantedAddressList, wantedEsigsList) {
    if (wantedAddressList.length !== wantedEsigsList.length)
      throw new Error("[-] source address list length != source event signature list length.");
    for (let i = 0; i < wantedAddressList.length; i++) {
      if (areEqualArrays(this.address, wantedAddressList[i])) {
        const esig = this.topics[0];
        const wantedEsigs = wantedEsigsList[i];
        for (let j = 0; j < wantedEsigs.length; j++) {
          if (areEqualArrays(esig, wantedEsigs[j]))
            return true;
        }
      }
    }
    return false;
  }
  match_one(wantedAddress, wantedEsigs) {
    if (areEqualArrays(this.address, wantedAddress)) {
      const esig = this.topics[0];
      for (let j = 0; j < wantedEsigs.length; j++) {
        if (areEqualArrays(esig, wantedEsigs[j])) {
          break;
        }
      }
    }
  }
  // TODO: must be match types and handle edge cases
  static fromRlp(rlpdata) {
    const address = rlpdata[0].data;
    const address_offset = rlpdata[0].dataIndexes;
    const topics = [];
    const topics_offset = [];
    for (let i = 0; i < rlpdata[1].data.length; i++) {
      topics.push(rlpdata[1].data[i].data);
      topics_offset.push(rlpdata[1].data[i].dataIndexes);
    }
    const data = rlpdata[2].data;
    const data_offset = rlpdata[2].dataIndexes;
    return new Event(
      address,
      topics,
      data,
      address_offset,
      topics_offset,
      data_offset
    );
  }
}

function encode(input) {
  if (Array.isArray(input)) {
    const output = [];
    for (let i = 0; i < input.length; i++)
      output.push(encode(input[i]));
    const buf = concatBytes(...output);
    return concatBytes(encodeLength(buf.length, 192), buf);
  }
  const inputBuf = toBytes(input);
  if (inputBuf.length === 1 && inputBuf[0] < 128)
    return inputBuf;
  return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
function decodeLength(v) {
  if (v[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
  if (len < 56)
    return Uint8Array.from([len + offset]);
  const hexLength = numberToHex(len);
  const lLength = hexLength.length / 2;
  const firstByte = numberToHex(offset + 55 + lLength);
  return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
  if (!input || input.length === 0)
    return Uint8Array.from([]);
  const inputBytes = toBytes(input);
  const decoded = _decode(inputBytes, 0);
  if (stream)
    return decoded;
  return decoded.data;
}
function _decode(input, start) {
  let length, llength, data;
  const firstByte = input[start];
  if (firstByte <= 127) {
    return {
      data: input.slice(start, start + 1),
      dataIndexes: [start, start],
      isList: false
    };
  } else if (firstByte <= 183) {
    length = firstByte - 128;
    if (firstByte === 128)
      data = Uint8Array.from([]);
    else
      data = input.slice(start + 1, start + 1 + length);
    if (length === 2 && data[start] < 128) {
      throw new Error(
        "invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed"
      );
    }
    return {
      data,
      dataIndexes: [start + 1, start + length],
      isList: false
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 183;
    if (input.length - start - 1 < llength)
      throw new Error("invalid RLP: not enough bytes for string length");
    length = decodeLength(input.slice(start + 1, start + 1 + llength));
    if (length <= 55) {
      throw new Error(
        "invalid RLP: expected string length to be greater than 55"
      );
    }
    data = input.slice(start + 1 + llength, start + 1 + length + llength);
    return {
      data,
      dataIndexes: [start + 1 + llength, start + length + llength],
      isList: false
    };
  } else if (firstByte <= 247) {
    length = firstByte - 192;
    return {
      data: _decodeList(input, start + 1, start + length),
      dataIndexes: [start + 1, start + length],
      isList: true
    };
  } else {
    llength = firstByte - 247;
    length = decodeLength(input.slice(start + 1, start + 1 + llength));
    if (length < 56)
      throw new Error("invalid RLP: encoded list too short");
    const totalLength = llength + length;
    if (start + totalLength > input.length)
      throw new Error("invalid RLP: total length is larger than the data");
    return {
      data: _decodeList(input, start + llength + 1, start + length + llength),
      dataIndexes: [start + llength + 1, start + totalLength],
      isList: true
    };
  }
}
function _decodeList(input, start, end) {
  let startIdx = start;
  const decoded = [];
  while (startIdx <= end) {
    const d = _decode(input, startIdx);
    decoded.push(d);
    startIdx = d.dataIndexes[1] + 1;
  }
  if (startIdx !== end + 1)
    throw new Error("invalid RLP: decode list input invalid");
  return decoded;
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => {
  return i.toString(16).padStart(2, "0");
});
function bytesToHex(uint8a) {
  let hex = "";
  for (let i = 0; i < uint8a.length; i++)
    hex += cachedHexes[uint8a[i]];
  return hex;
}
function parseHexByte(hexByte) {
  const byte = Number.parseInt(hexByte, 16);
  if (Number.isNaN(byte))
    throw new Error("Invalid byte sequence");
  return byte;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    array[i] = parseHexByte(hex.slice(j, j + 2));
  }
  return array;
}
function concatBytes(...arrays) {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function utf8ToBytes(utf) {
  return new TextEncoder().encode(utf);
}
function numberToHex(integer) {
  if (integer < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const hex = integer.toString(16);
  return hex.length % 2 ? `0${hex}` : hex;
}
function padToEven(a) {
  return a.length % 2 ? `0${a}` : a;
}
function isHexPrefixed(str) {
  return str.length >= 2 && str[0] === "0" && str[1] === "x";
}
function stripHexPrefix(str) {
  if (typeof str !== "string")
    return str;
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function toBytes(v) {
  if (v instanceof Uint8Array)
    return v;
  if (typeof v === "string") {
    if (isHexPrefixed(v))
      return hexToBytes(padToEven(stripHexPrefix(v)));
    return utf8ToBytes(v);
  }
  if (typeof v === "number" || typeof v === "bigint") {
    if (!v)
      return Uint8Array.from([]);
    return hexToBytes(numberToHex(v));
  }
  if (v === null || v === void 0)
    return Uint8Array.from([]);
  throw new Error(`toBytes: received unsupported type ${typeof v}`);
}
const utils = {
  bytesToHex,
  concatBytes,
  hexToBytes,
  utf8ToBytes
};
const RLP = { encode, decode, ...utils };
var RLP$1 = RLP;

class TxReceipt {
  status;
  gasUsed;
  logsBloom;
  events;
  constructor(status, gasUsed, logsBloom, events) {
    this.status = status;
    this.gasUsed = gasUsed;
    this.logsBloom = logsBloom;
    this.events = events;
  }
  static fromRawBin(rawReceipt) {
    if (rawReceipt[0] <= 2) {
      rawReceipt = rawReceipt.slice(1);
    }
    const rlpdata = RLP$1.decode(rawReceipt);
    const status = rlpdata[0].data[0];
    const gasUsed = rlpdata[1].data[0];
    const logsBloom = rlpdata[2].data;
    const rlpevents = rlpdata[3].data;
    const events = [];
    for (let i = 0; i < rlpevents.length; i++)
      events.push(Event.fromRlp(rlpevents[i].data));
    return new TxReceipt(status, gasUsed, logsBloom, events);
  }
  static fromRawStr(rawReceiptStr) {
    return TxReceipt.fromRawBin(fromHexString(rawReceiptStr));
  }
  toValidEvents() {
    if (this.status !== 1) {
      return [];
    } else {
      return this.events;
    }
  }
  filter(wantedAddressList, wantedEsigsList) {
    const events = this.toValidEvents();
    const rst = [];
    for (let i = 0; i < events.length; i++) {
      if (events[i].match(wantedAddressList, wantedEsigsList))
        rst.push(events[i]);
    }
    return rst;
  }
}

function eventTo7Offsets(event, receiptBaseOffset) {
  const rst = [event.address_offset[0] + receiptBaseOffset];
  for (let i = 0; i < 4; i++) {
    rst.push(
      i < event.topics.length ? event.topics_offset[i][0] + receiptBaseOffset : 0
    );
  }
  rst.push(event.data_offset[0] + receiptBaseOffset);
  rst.push(event.data.length);
  return rst;
}
function cleanReceipt(r) {
  return trimPrefix(trimPrefix(r, "0x"), "02");
}
function rlpDecodeAndEventFilter(rawreceiptList, srcAddrList, srcEsigsList) {
  const filteredRawReceiptList = [];
  const filteredEventsList = [];
  for (const i in rawreceiptList) {
    const es = TxReceipt.fromRawStr(rawreceiptList[i]).filter(
      srcAddrList,
      srcEsigsList
    );
    if (es.length > 0) {
      filteredRawReceiptList.push(rawreceiptList[i]);
      filteredEventsList.push(es);
    }
  }
  return [filteredRawReceiptList, filteredEventsList];
}
function genStreamAndMatchedEventOffsets(rawreceiptList, eventList) {
  let matched_offset_list = [];
  let accumulateReceiptLength = 0;
  let rawreceipts = "";
  assert(rawreceiptList.length === eventList.length);
  for (const rcpid in rawreceiptList) {
    const es = eventList[rcpid];
    matched_offset_list = matched_offset_list.concat(
      ...es.map((e) => eventTo7Offsets(e, accumulateReceiptLength))
    );
    const r = cleanReceipt(rawreceiptList[rcpid]);
    rawreceipts += r;
    accumulateReceiptLength += Math.ceil(r.length / 2);
  }
  return [fromHexString(rawreceipts), matched_offset_list];
}
function filterEvents(eventDSAddrList, eventDSEsigsList, rawreceiptList, enableLog) {
  const [filteredRawReceiptList, filteredEventList] = rlpDecodeAndEventFilter(
    rawreceiptList,
    eventDSAddrList.map((addr) => fromHexString(addr)),
    eventDSEsigsList.map((esigList) => esigList.map((esig) => fromHexString(esig)))
  );
  let [rawReceipts, matchedEventOffsets] = genStreamAndMatchedEventOffsets(
    filteredRawReceiptList,
    filteredEventList
  );
  if (enableLog) {
    logReceiptAndEvents(
      rawreceiptList,
      matchedEventOffsets,
      filteredEventList
    );
  }
  matchedEventOffsets = Uint32Array.from(matchedEventOffsets);
  return [rawReceipts, matchedEventOffsets];
}
function createFileFromUint8Array(array, fileName) {
  {
    const tempDir = os.tmpdir();
    const filePath = path.join(tempDir, fileName);
    fs.writeFileSync(filePath, array);
    return fs.createReadStream(filePath);
  }
}

function fillInputBlocks(input, zkgraphYaml, blockPrepMap, blocknumOrder, latestBlockhash) {
  const blockCount = blocknumOrder.length;
  input.addInt(blockCount, false);
  blocknumOrder.forEach((bn) => {
    if (!blockPrepMap.has(bn))
      throw new Error(`Lack blockPrep for block (${bn})`);
    fillInputOneBlock(input, zkgraphYaml, blockPrepMap.get(bn));
  });
  input.addHexString(latestBlockhash, true);
  return input;
}
function fillInputOneBlock(input, zkgraphYaml, blockPrep) {
  input.addInt(blockPrep.number, false);
  input.addVarLenHexString(
    blockPrep == null ? void 0 : blockPrep.rlpHeader,
    false
  );
  const ds = zkgraphYaml.getFilteredSourcesByKind("ethereum")[0];
  if (ds.storage) {
    const [stateDSAddrList, stateDSSlotsList] = ds.getStorageLists();
    input.addInt(stateDSAddrList.length, false);
    console.log("[*] Defined Data Sources - Storage:");
    for (let i = 0; i < stateDSAddrList.length; i++) {
      console.log(
        `    (${i}) Address:`,
        stateDSAddrList[i],
        "\n        Slot keys:",
        stateDSSlotsList[i],
        "\n"
      );
      input.addHexString(stateDSAddrList[i], false);
      const acctPrep = blockPrep == null ? void 0 : blockPrep.getAccount(stateDSAddrList[i]);
      input.addVarLenHexString(acctPrep == null ? void 0 : acctPrep.rlpNode, false);
      input.addVarLenHexStringArray(acctPrep == null ? void 0 : acctPrep.accountProof, false);
      const sourceSlots = stateDSSlotsList[i];
      input.addInt(sourceSlots.length, false);
      for (let j = 0; j < sourceSlots.length; j++) {
        const slotPrep = acctPrep == null ? void 0 : acctPrep.getSlot(sourceSlots[j]);
        if (slotPrep.storageProof == null)
          throw new Error(`In ExecInputGen: slot ${sourceSlots[j]} doesn't exist on given block height, storage proof == null. 
 Please update yaml or use later blocknumber.`);
        input.addHexString(sourceSlots[j], false);
        input.addVarLenHexString(slotPrep.value, false);
        input.addVarLenHexStringArray(slotPrep.storageProof, false);
      }
    }
  } else {
    console.log("[*] No storage DS provided, skip...");
    input.addInt(0, false);
  }
  if (ds.event) {
    const enableLog = true;
    const [eventDSAddrList, eventDSEsigsList] = ds.getEventLists();
    console.log("[*] Defined Data Sources - Event:");
    for (let i = 0; i < eventDSAddrList.length; i++)
      console.log(`    (${i}) Address:`, eventDSAddrList[i], "\n        Event Sigs:", eventDSEsigsList[i], "\n");
    const rawreceiptList = blockPrep == null ? void 0 : blockPrep.getRLPReceipts();
    const [rawReceipts] = filterEvents(
      eventDSAddrList,
      eventDSEsigsList,
      rawreceiptList,
      enableLog
    );
    const receiptCount = (rawReceipts.length > 0 ? rawreceiptList == null ? void 0 : rawreceiptList.length : 0) || 0;
    input.addInt(receiptCount, false);
    if (receiptCount > 0) {
      input.addVarLenHexString(toHexString(rawReceipts), false);
    }
  } else {
    console.log("[*] No event DS provided, skip...");
    input.addInt(0, false);
  }
  return input;
}

class EthereumDataPrep extends DataPrep {
  blockPrepMap;
  blocknumberOrder;
  latestBlockhash;
  expectedStateStr;
  constructor(blockPrepMap, blocknumberOrder, latestBlockhash, expectedStateStr) {
    super();
    this.blockPrepMap = blockPrepMap;
    this.blocknumberOrder = blocknumberOrder;
    this.latestBlockhash = latestBlockhash;
    this.expectedStateStr = expectedStateStr;
  }
}
class SlotPrep {
  key;
  value;
  storageProof;
  constructor(key, value, storageProof) {
    this.key = key;
    this.value = value;
    this.storageProof = storageProof;
  }
}
class AccountPrep {
  address;
  rlpNode;
  accountProof;
  slots;
  constructor(address, rlpNode, accountProof) {
    this.address = address;
    this.rlpNode = rlpNode;
    this.accountProof = accountProof;
    this.slots = /* @__PURE__ */ new Map();
  }
  addSlot(key, value, storageProof) {
    this.slots.set(
      key,
      new SlotPrep(key, value, storageProof)
    );
  }
  getSlot(key) {
    if (!this.hashSlot(key))
      throw new Error(`Lack data in blockPrep: slot (${key})`);
    return this.slots.get(key);
  }
  hashSlot(key) {
    return this.slots.has(key);
  }
  addFromStorageProofList(storageProofList) {
    storageProofList.forEach((sp) => {
      this.addSlot(sp.key, sp.value, sp.proof);
    });
  }
}
class BlockPrep {
  number;
  rlpHeader;
  accounts;
  rlpreceipts;
  constructor(blocknum, rlpHeader) {
    this.number = blocknum;
    this.rlpHeader = rlpHeader;
    this.accounts = /* @__PURE__ */ new Map();
    this.rlpreceipts = [];
  }
  addAccount(address, rlpAccount, accountProof) {
    this.accounts.set(
      address,
      new AccountPrep(address, rlpAccount, accountProof)
    );
  }
  getAccount(address) {
    if (!this.hasAccount(address))
      throw new Error(`Lack data in blockPrep: account (${address})`);
    return this.accounts.get(address);
  }
  hasAccount(address) {
    return this.accounts.has(address);
  }
  addFromGetProofResult(ethproof, accountRLP = null) {
    var _a;
    const accountAddress = ethproof.address;
    if (!this.accounts.has(accountAddress)) {
      if (accountRLP == null)
        throw new Error("lack of accountRLP when new Account");
      this.addAccount(accountAddress, accountRLP, ethproof.accountProof);
    }
    (_a = this.getAccount(accountAddress)) == null ? void 0 : _a.addFromStorageProofList(ethproof.storageProof);
  }
  addRLPReceipts(rlpReceiptList) {
    rlpReceiptList.forEach((rlpRcpt) => {
      this.rlpreceipts.push(rlpRcpt);
    });
  }
  getRLPReceipts() {
    return this.rlpreceipts;
  }
}

async function prepareBlocksByYaml(provider, latestBlocknumber, latestBlockhash, expectedStateStr, zkgraphYaml) {
  const blockPrep = await prepareOneBlockByYaml(provider, latestBlocknumber, zkgraphYaml);
  const blockPrepMap = /* @__PURE__ */ new Map();
  blockPrepMap.set(latestBlocknumber, blockPrep);
  const blocknumOrder = [latestBlocknumber];
  return new EthereumDataPrep(blockPrepMap, blocknumOrder, latestBlockhash, expectedStateStr);
}
async function prepareOneBlockByYaml(provider, blockNumber, zkgraphYaml) {
  let stateDSAddrList, stateDSSlotsList;
  const ds = zkgraphYaml.getFilteredSourcesByKind("ethereum")[0];
  if (ds.storage)
    [stateDSAddrList, stateDSSlotsList] = ds.getStorageLists();
  else
    [stateDSAddrList, stateDSSlotsList] = [[], []];
  const needRLPReceiptList = ds.event != null;
  return await prepareOneBlock(provider, blockNumber, stateDSAddrList, stateDSSlotsList, needRLPReceiptList);
}
async function prepareOneBlock(provider, blockNumber, stateDSAddrList, stateDSSlotsList, needRLPReceiptList) {
  const block = new BlockPrep(
    blockNumber,
    // header rlp
    "0xf9023ba0471046357a104b659365e6cf9751fb2b82c7c57ad40ce6577187433280787a91a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0632a7359190018d7a9874f757fd3b9719bf1aa8b84c66c53027f3bda220676b0a009218adecad9f3c086e5bed1e2c42f2bf89f95042855c52d379d13acaf631ad0a0cd74a2298267317f57c3b454e39dcc20f1d5c1c02dc5ac6d33d6e81499306ccdb901002881080818140000c07854415cf181c104898088020c06008860c40200124c0208a000704940401031013802d0480880208a340254260140022101004324a222a10aa01058a23429998010388ca996009027185814a44398200a40000010a28e0fa4400cc6a24210028900a480020bd90201428020000400c1820212458284304002040512102131216004c848516580501905a0010c8c00891000808442046707188023010080222008004000000c08180ae0588a90004a00209108240a40102012000b402328560cb064051300042010602330020a06008290d7480168681292d302054091203180000602a23128044a408038201010054204a020264c50408083455e458401c9c38083b0818b846536428899d883010d01846765746888676f312e32312e31856c696e7578a083a009e788fed9edb6444cd1305367be5090da1993f8958930cd54a44ce1f8118800000000000000008516d9f2e506a0adef2eee900e520200c9d53d7b56fee4d685a3ef5391ba4beed002fe110e887d"
  );
  for (let i = 0; i < stateDSAddrList.length; i++) {
    const ethproof = await getProof(
      provider,
      stateDSAddrList[i],
      stateDSSlotsList[i],
      ethers.ethers.utils.hexValue(blockNumber)
    );
    block.addFromGetProofResult(ethproof, "0xaaaaaa");
  }
  if (needRLPReceiptList) {
    const rawreceiptList = await getRawReceipts(provider, blockNumber).catch(
      (error) => {
        throw error;
      }
    );
    block.addRLPReceipts(rawreceiptList);
  }
  return block;
}

class EthereumDataSourcePlugin extends DataSourcePlugin {
  // SHOULD align with zkgraph-lib/dsp/<DSPName>
  getLibDSPName() {
    return "ethereum";
  }
  async prepareData(zkgraphYaml, prepareParams) {
    const { provider, latestBlocknumber, latestBlockhash, expectedStateStr } = prepareParams;
    const dataPrep = await prepareBlocksByYaml(provider, latestBlocknumber, latestBlockhash, expectedStateStr || "", zkgraphYaml);
    return dataPrep;
  }
  fillExecInput(input, zkgraphYaml, dataPrep) {
    return fillInputBlocks(input, zkgraphYaml, dataPrep.blockPrepMap, dataPrep.blocknumberOrder, dataPrep.latestBlockhash);
  }
  fillProveInput(input, zkgraphYaml, dataPrep) {
    this.fillExecInput(input, zkgraphYaml, dataPrep);
    const expectedStateStr = trimPrefix(dataPrep.expectedStateStr, "0x");
    input.addVarLenHexString(expectedStateStr, true);
    return input;
  }
  // TODO: copy instead of rename
  toProveDataPrep(execDataPrep, execResult) {
    const proveDataPrep = execDataPrep;
    proveDataPrep.expectedStateStr = execResult;
    return proveDataPrep;
  }
  execParams = ["provider", "blockId"];
  proveParams = ["provider", "blockId", "expectedStateStr"];
  async toPrepareParams(params, type) {
    let expectedStateStr = "";
    const { provider, blockId } = params;
    if (type === "prove")
      expectedStateStr = params.expectedStateStr || "";
    const rawblock = await getBlock(provider, blockId);
    const blockNumber = parseInt(rawblock.number);
    const blockHash = rawblock.hash;
    return {
      provider,
      latestBlocknumber: blockNumber,
      latestBlockhash: blockHash,
      expectedStateStr
    };
  }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EthereumDataPrep: EthereumDataPrep,
  EthereumDataSourcePlugin: EthereumDataSourcePlugin
});

class EthereumOffchainDP extends DataPrep {
  blockPrepMap;
  blocknumberOrder;
  latestBlockhash;
  offchainData;
  expectedStateStr;
  constructor(blockPrepMap, blocknumberOrder, latestBlockhash, offchainData, expectedStateStr) {
    super();
    this.blockPrepMap = blockPrepMap;
    this.blocknumberOrder = blocknumberOrder;
    this.latestBlockhash = latestBlockhash;
    this.offchainData = offchainData;
    this.expectedStateStr = expectedStateStr;
  }
}
class EthereumOffchainDSP extends DataSourcePlugin {
  // SHOULD align with zkgraph-lib/dsp/<DSPName>
  getLibDSPName() {
    return "ethereum-offchain.bytes";
  }
  async prepareData(zkgraphYaml, prepareParams) {
    const { provider, latestBlocknumber, latestBlockhash, offchainData, expectedStateStr } = prepareParams;
    const ethDP = await prepareBlocksByYaml(provider, latestBlocknumber, latestBlockhash, expectedStateStr || "", zkgraphYaml);
    return new EthereumOffchainDP(
      ethDP.blockPrepMap,
      ethDP.blocknumberOrder,
      ethDP.latestBlockhash,
      // add offchain data
      offchainData,
      ethDP.expectedStateStr
    );
  }
  fillExecInput(input, zkgraphYaml, dataPrep) {
    input = fillInputBlocks(input, zkgraphYaml, dataPrep.blockPrepMap, dataPrep.blocknumberOrder, dataPrep.latestBlockhash);
    input.addVarLenHexString(dataPrep.offchainData);
    return input;
  }
  fillProveInput(input, zkgraphYaml, dataPrep) {
    this.fillExecInput(input, zkgraphYaml, dataPrep);
    input.addVarLenHexString(dataPrep.offchainData);
    const expectedStateStr = trimPrefix(dataPrep.expectedStateStr, "0x");
    input.addVarLenHexString(expectedStateStr, true);
    return input;
  }
  // TODO: copy instead of rename
  toProveDataPrep(execDataPrep, execResult) {
    const proveDataPrep = execDataPrep;
    proveDataPrep.expectedStateStr = execResult;
    return proveDataPrep;
  }
  execParams = ["blockId", "offchainData"];
  proveParams = ["blockId", "offchainData", "expectedStateStr"];
  async toPrepareParams(params, type) {
    let expectedStateStr = "";
    const { provider, blockId, offchainData } = params;
    if (type === "prove")
      expectedStateStr = params.expectedStateStr || "";
    const rawblock = await getBlock(provider, blockId);
    const blockNumber = parseInt(rawblock.number);
    const blockHash = rawblock.hash;
    return {
      provider,
      latestBlocknumber: blockNumber,
      latestBlockhash: blockHash,
      // add offchain data
      offchainData,
      expectedStateStr
    };
  }
}

class EthereumLocalDataSourcePlugin extends DataSourcePlugin {
  prepareData(zkgraphYaml, prepareParams) {
    throw new Error("Method not implemented.");
  }
  fillExecInput(input, zkgraphYaml, dataPrep) {
    return input;
  }
  fillProveInput(input, zkgraphYaml, dataPrep) {
    return input;
  }
  toProveDataPrep(execDataPrep, execResult) {
    return {};
  }
  execParams = [];
  proveParams = [];
  // SHOULD align with zkgraph-lib/dsp/<DSPName>
  getLibDSPName() {
    return "ethereum_local";
  }
  toPrepareParams(params, type) {
    throw new Error("Method not implemented.");
  }
}

class DSPHub {
  hub = /* @__PURE__ */ new Map();
  /**
   * @param {string} primaryKey yaml.dataSources[i].kind
   * @param {object} foreignKeys {"isLocal": boolean}
   * @returns Combined Key String: Better to be human readable
   */
  toHubKey(primaryKey, foreignKeys) {
    const { isLocal } = foreignKeys;
    const keyFullLocal = !isLocal || isLocal == null ? "full" : "local";
    return `${primaryKey}:${keyFullLocal}`;
  }
  toHubKeyByYaml(zkgraphYaml, foreignKeys) {
    const sigKeys = zkgraphYaml.getSignificantKeys(true);
    const primaryKey = this.toPrimaryKey(sigKeys);
    return this.toHubKey(primaryKey, foreignKeys);
  }
  toPrimaryKey(sigKeys) {
    return sigKeys.map((keys) => keys.join(".")).join("-");
  }
  setDSP(primaryKey, foreignKeys, dsp) {
    this.hub.set(this.toHubKey(primaryKey, foreignKeys), dsp);
  }
  getDSP(primaryKey, foreignKeys) {
    const key = this.toHubKey(primaryKey, foreignKeys);
    if (!this.hub.has(key))
      throw new Error(`Data Source Plugin Hub Key "${key}" doesn't exist.`);
    return this.hub.get(key);
  }
  getDSPByYaml(zkgraphYaml, foreignKeys) {
    const sigKeys = zkgraphYaml.getSignificantKeys(true);
    const primaryKey = this.toPrimaryKey(sigKeys);
    return this.getDSP(primaryKey, foreignKeys);
  }
}
const dspHub = new DSPHub();
dspHub.setDSP("ethereum", { isLocal: false }, new EthereumDataSourcePlugin());
dspHub.setDSP("ethereum", { isLocal: true }, new EthereumLocalDataSourcePlugin());
dspHub.setDSP("ethereum-offchain.bytes", { isLocal: false }, new EthereumOffchainDSP());

class DataSource {
  kind;
  constructor(kind) {
    this.kind = kind;
  }
  getSignificantKeys() {
    throw new Error(`default: getSignificantKeys not implemented for DataSource kind ${this.kind}.`);
  }
  healthCheck() {
    throw new Error(`default: healthCheck not implemented for DataSource kind ${this.kind}.`);
  }
}
class DataDestination {
  kind;
  constructor(kind) {
    this.kind = kind;
  }
  getSignificantKeys() {
    throw new Error(`default: getSignificantKeys not implemented for DataDestination kind ${this.kind}.`);
  }
  healthCheck() {
    throw new Error(`default: healthCheck not implemented for DataDestination kind ${this.kind}.`);
  }
}
class Mapping {
  language;
  file;
  handler;
  constructor(language, file, handler) {
    this.language = language;
    this.file = file;
    this.handler = handler;
  }
  static from_v_0_0_2(yamlMapping) {
    return new Mapping(
      yamlMapping.language,
      yamlMapping.file,
      yamlMapping.handler
    );
  }
  static from_v_0_0_1(_yamlMapping) {
    return null;
  }
}

function isEthereumAddress(address) {
  try {
    const parsedAddress = ethers.ethers.utils.getAddress(address);
    return parsedAddress !== "0x0000000000000000000000000000000000000000";
  } catch (error) {
    return false;
  }
}
class EventSection {
  constructor(addressList, esigsList) {
    this.addressList = addressList;
    this.esigsList = esigsList;
    this.addressList = addressList.map((item) => item.toLocaleLowerCase());
  }
}
class StorageSection {
  constructor(addressList, slotsList) {
    this.addressList = addressList;
    this.slotsList = slotsList;
    this.addressList = addressList.map((item) => item.toLocaleLowerCase());
  }
}
class EthereumDataSource extends DataSource {
  network;
  // event: EventSection | null
  // storage: StorageSection | null
  event;
  storage;
  account;
  block;
  eventSectionCache = null;
  storageSectionCache = null;
  constructor(kind, network, event, storage, account, block) {
    super(kind);
    this.network = network;
    this.event = event;
    this.storage = storage;
    this.account = account;
    this.block = block;
  }
  static from_v_0_0_2(yamlEthDS) {
    return new EthereumDataSource(
      yamlEthDS.kind,
      yamlEthDS.network,
      // (yamlEthDS.event != null) ? EventSection.from_v_0_0_2(yamlEthDS.event) : null,
      // (yamlEthDS.storage != null) ? StorageSection.from_v_0_0_2(yamlEthDS.storage) : null,
      yamlEthDS.event,
      yamlEthDS.storage,
      null,
      // TODO: account section
      null
      // TODO: block section
    );
  }
  static from_v_0_0_1(_yamlEthDS) {
    throw new Error("no 0.0.1 support");
  }
  // signaficant to decide which lib dsp main it should use.
  getSignificantKeys() {
    return [this.kind];
  }
  getEventLists(useCache = true) {
    if (!useCache || this.eventSectionCache == null) {
      const loadFromEventSource = (event) => {
        const source_address = event.address;
        const source_esigs = event.events.map((ed) => {
          const eventHash = ed.startsWith("0x") ? ed : ethers.ethers.utils.keccak256(ethers.ethers.utils.toUtf8Bytes(ed));
          return eventHash;
        });
        return [source_address, source_esigs];
      };
      const eventDSAddrList = [];
      const eventDSEsigsList = [];
      if (this.event)
        this.event.forEach((event) => {
          const [sa, se] = loadFromEventSource(event);
          eventDSAddrList.push(sa);
          eventDSEsigsList.push(se);
        });
      this.eventSectionCache = new EventSection(eventDSAddrList, eventDSEsigsList);
    }
    return [this.eventSectionCache.addressList, this.eventSectionCache.esigsList];
  }
  getStorageLists(useCache = true) {
    if (!useCache || this.storageSectionCache == null) {
      const loadFromStorageSource = (storage) => {
        const source_address = storage.address.toLocaleLowerCase();
        const source_slots = storage.slots.map((sl) => {
          return ethers.ethers.utils.hexZeroPad(sl, 32);
        });
        return [source_address, source_slots];
      };
      const stateDSAddrList = [];
      const stateDSSlotsList = [];
      if (this.storage) {
        this.storage.forEach((storage) => {
          const [sa, sl] = loadFromStorageSource(storage);
          stateDSAddrList.push(sa);
          stateDSSlotsList.push(sl);
        });
      }
      this.storageSectionCache = new StorageSection(stateDSAddrList, stateDSSlotsList);
    }
    return [this.storageSectionCache.addressList, this.storageSectionCache.slotsList];
  }
  static healthCheck(ds) {
    const eventCount = ds.event ? 1 : 0;
    const storageCount = ds.storage ? 1 : 0;
    if (eventCount + storageCount !== 1)
      throw new YamlNotSupported("currently requires only one 'event' or 'storage' field");
  }
}
class EthereumDataDestination extends DataDestination {
  network;
  address;
  constructor(kind, network, address) {
    super(kind);
    this.network = network;
    this.address = address;
  }
  // signaficant to decide which lib dsp main it should use.
  getSignificantKeys() {
    return [this.kind];
  }
  static from_v_0_0_2(yamlEthDD) {
    return new EthereumDataDestination(
      yamlEthDD.kind,
      yamlEthDD.network,
      yamlEthDD.address
    );
  }
  static from_v_0_0_1(yamlEthDD) {
    return new EthereumDataDestination(
      yamlEthDD.kind,
      yamlEthDD.network,
      yamlEthDD.destination.address
    );
  }
  static healthCheck(dd) {
    if (!dd.network || !dd.address)
      throw new YamlHealthCheckFailed("dataDestinations object is missing required fields");
    if (!isEthereumAddress(dd.address))
      throw new YamlHealthCheckFailed("Invalid Ethereum address in dataDestinations");
  }
}

class OffchainDataSource extends DataSource {
  type;
  constructor(kind, type) {
    super(kind);
    this.type = type;
  }
  // signaficant to decide which lib dsp main it should use.
  getSignificantKeys() {
    return [this.kind, this.type];
  }
  static from_v_0_0_2(yamlOffDS) {
    return new OffchainDataSource(
      yamlOffDS.kind,
      yamlOffDS.type
      // CustomDataSection.from_v_0_0_2(yamlOffDS.data)
    );
  }
  static from_v_0_0_1(_yamlOffDS) {
    throw new Error("offchain dataSource is only supported in spec >= v0.0.2");
  }
  static healthCheck(yamlOffDS) {
    if (yamlOffDS.kind !== "offchain")
      throw new YamlHealthCheckFailed(`offchain dataSource is parsing wrong 'kind'. expect offchain, but got ${yamlOffDS.kind}.`);
    if (!yamlOffDS.type)
      throw new YamlHealthCheckFailed("offchain dataSource missing `type`");
    const validType = ["bytes"];
    if (!validType.includes(yamlOffDS.type))
      throw new YamlNotSupported(`Invalid offchain dataSource \`type\`, only support ${validType.toString()}`);
  }
}

const dataSourceClassMap = /* @__PURE__ */ new Map();
dataSourceClassMap.set("ethereum", EthereumDataSource);
dataSourceClassMap.set("offchain", OffchainDataSource);
const dataDestinationClassMap = /* @__PURE__ */ new Map();
dataDestinationClassMap.set("ethereum", EthereumDataDestination);
class ZkGraphYaml {
  specVersion;
  apiVersion;
  description;
  repository;
  dataSources;
  dataDestinations;
  mapping;
  name;
  constructor(specVersion, apiVersion, name, description, repository, dataSources, dataDestinations, mapping) {
    this.specVersion = specVersion;
    this.apiVersion = apiVersion;
    this.name = name;
    this.description = description;
    this.repository = repository;
    this.dataSources = dataSources;
    this.dataDestinations = dataDestinations;
    this.mapping = mapping;
  }
  static from_v_0_0_2(yaml2) {
    const dataSources = [];
    yaml2.dataSources.forEach((ds) => {
      var _a;
      return dataSources.push((_a = dataSourceClassMap.get(ds.kind)) == null ? void 0 : _a.from_v_0_0_2(ds));
    });
    const dataDestinations = [];
    yaml2.dataDestinations.forEach((dd) => dataDestinations.push(dataDestinationClassMap.get(dd.kind).from_v_0_0_2(dd)));
    return new ZkGraphYaml(
      yaml2.specVersion,
      yaml2.apiVersion,
      yaml2.name,
      yaml2.description,
      yaml2.repository,
      dataSources,
      dataDestinations,
      Mapping.from_v_0_0_2(yaml2.mapping)
    );
  }
  // TODO: type: should be the return class of yaml.load
  static fromYaml(yaml2) {
    ZkGraphYaml.healthCheck(yaml2);
    if (yaml2.specVersion === "0.0.1")
      return ZkGraphYaml.from_v_0_0_1(yaml2);
    else if (yaml2.specVersion === "0.0.2")
      return ZkGraphYaml.from_v_0_0_2(yaml2);
    else
      throw new Error(`Unsupported specVersion: ${yaml2.specVersion}`);
  }
  static fromYamlContent(yamlContent) {
    try {
      const config = yaml.load(yamlContent);
      return ZkGraphYaml.fromYaml(config);
    } catch (error) {
      throw new YamlInvalidFormat(error.message);
    }
  }
  // TODO: remove this func, this should be outside the scope of api.
  static fromYamlPath(yamlPath) {
    {
      let fileContents = "";
      try {
        fileContents = fs.readFileSync(yamlPath, "utf8");
      } catch (error) {
        console.error(error);
      }
      return ZkGraphYaml.fromYamlContent(fileContents);
    }
  }
  static from_v_0_0_1(_yaml) {
    throw new Error("no 0.0.1 support");
  }
  // // const config = ;
  // sourceType() { //TODO
  //   if (this.specVersion >= "0.0.2"){
  //     if (this.dataSources[0].event) {
  //       return "event";
  //     } else if (this.dataSources[0].storage) {
  //       return "storage";
  //     } else {
  //       throw new Error("At least includes event or storage section in dataSources[0]")
  //     }
  //   } else if (this.specVersion == "0.0.1"){
  //     return "event"; // 0.0.1 only support event
  //   }
  //   throw new Error("Unsupported specVersion: ", this.specVersion)
  // }
  getSignificantKeys(isSource) {
    return isSource ? this.dataSources.map((ds) => ds.getSignificantKeys()) : this.dataDestinations.map((ds) => ds.getSignificantKeys());
  }
  getFilteredSourcesByKind(kind) {
    return this.dataSources.filter((ds) => ds.kind === kind);
  }
  static healthCheck(yaml2) {
    if (!yaml2.specVersion || typeof yaml2.specVersion !== "string" || yaml2.specVersion.trim() === "")
      throw new YamlHealthCheckFailed("specVersion is missing or empty");
    if (semver.gt(yaml2.specVersion, "0.0.2"))
      throw new YamlHealthCheckFailed("Invalid specVersion, it should be <= 0.0.2");
    if (!yaml2.apiVersion || typeof yaml2.apiVersion !== "string" || yaml2.apiVersion.trim() === "")
      throw new YamlHealthCheckFailed("apiVersion is missing or empty");
    if (semver.gt(yaml2.apiVersion, "0.0.2"))
      throw new YamlHealthCheckFailed("Invalid apiVersion, it should be <= 0.0.2");
    if (!yaml2.dataSources || yaml2.dataSources.length === 0)
      throw new YamlHealthCheckFailed("dataSources should not be empty");
    const sourceKinds = [];
    yaml2.dataSources.forEach((dataSource) => {
      if (!dataSource.kind)
        throw new YamlHealthCheckFailed("dataSource is missing 'kind' field");
      sourceKinds.push(dataSource.kind);
    });
    const validKind = ["ethereum", "offchain"];
    if (!sourceKinds.every((kind) => validKind.includes(kind)))
      throw new YamlHealthCheckFailed(`Invalid dataSource kind, only support ${validKind.toString()}`);
    if (sourceKinds.indexOf("ethereum") !== sourceKinds.lastIndexOf("ethereum"))
      throw new YamlHealthCheckFailed("Only 1 'ethereum' kind is allowed in data sources right now");
    yaml2.dataSources.forEach((dataSource) => {
      var _a;
      (_a = dataSourceClassMap.get(dataSource.kind)) == null ? void 0 : _a.healthCheck(dataSource);
    });
    if (!yaml2.mapping.language || !yaml2.mapping.file || !yaml2.mapping.handler)
      throw new YamlHealthCheckFailed("Some required fields are empty in mapping");
    yaml2.dataDestinations.forEach((dataDest) => {
      if (!dataDest.kind)
        throw new YamlHealthCheckFailed("dataDestination is missing 'kind' field");
      dataDestinationClassMap.get(dataDest.kind).healthCheck(dataDest);
    });
  }
}

class HostMemory {
  mem;
  writecur;
  readcur;
  view;
  constructor(max_size) {
    this.mem = new Uint8Array(max_size);
    this.writecur = 0;
    this.readcur = 0;
    this.view = new DataView(this.mem.buffer);
  }
  push(data, little_endian = true) {
    if (little_endian) {
      for (let i = 0; i < data.length; i++)
        this.mem[this.writecur + i] = data[i];
    } else {
      for (let i = 0; i < data.length; i++)
        this.mem[this.writecur + data.length - 1 - i] = data[i];
    }
    this.writecur += data.length;
  }
  push_align(data, little_endian = true) {
    const padlen = Math.ceil(data.length / 8) * 8 - data.length;
    this.push(data, little_endian);
    this.push(new Uint8Array(padlen));
  }
  write_once(data, type) {
    if (type === "i64") {
      this.push_align(data, false);
    } else if (type === "bytes-packed") {
      this.push_align(data, true);
    } else {
      throw new Error(
        `zkwasm mock: data type (${type}) not supported, please file an issue if you think it should be supported.`
      );
    }
  }
  write_from_input(str) {
    const args = str.split(" ");
    for (const i in args) {
      if (args[i].length === 0)
        continue;
      const _arg = args[i].split(":");
      if (_arg.length > 2)
        throw new Error(`multiple ':' in "${args[i]}"`);
      const [d, t] = [_arg[0], _arg[1]];
      this.write_once(fromHexString(d), t);
    }
  }
  print(title = "") {
    console.log(`---------------${title}---------------`);
    console.log(`>> total length: ${this.writecur}`);
    console.log(">> data: ");
    console.log(toHexString(this.mem.slice(0, this.writecur)));
    console.log(`------------------------------${"-".repeat(title.length)}`);
  }
  read_i64() {
    this.readcur += 8;
    return this.view.getBigUint64(this.readcur - 8, true);
  }
}
class ZKWASMMock {
  privateMem;
  publicMem;
  constructor(max_pri_size = 1e8, max_pub_size = 1e3) {
    this.privateMem = new HostMemory(max_pri_size);
    this.publicMem = new HostMemory(max_pub_size);
  }
  set_private_input(str) {
    this.privateMem.write_from_input(str);
  }
  set_public_input(str) {
    this.publicMem.write_from_input(str);
  }
  static require(a) {
    if (!a) {
      throw new ZKGraphRequireFailed("Abort execution since the require condition is false.");
    }
  }
  wasm_input(a) {
    if (a === 0)
      return this.privateMem.read_i64();
    else if (a === 1)
      return this.publicMem.read_i64();
    else
      throw new Error("zkwasm mock: wasm_input is invalid: ", a);
  }
}

let zkwasmmock;
function setupZKWasmMock(mock) {
  zkwasmmock = mock;
}
exports.hasDebugOnlyFunc = false;
async function instantiate(module, imports = {}) {
  exports.hasDebugOnlyFunc = false;
  const adaptedImports = {
    env: Object.assign(Object.create(globalThis), imports.env || {}, {
      "wasm_write_context": function(_) {
      },
      "console.log": function(text) {
        if (!text)
          return;
        text = __liftString(text >>> 0);
        console.log(text);
        exports.hasDebugOnlyFunc = true;
      },
      require(x) {
        ZKWASMMock.require(x);
      },
      wasm_input(x) {
        return (zkwasmmock == null ? void 0 : zkwasmmock.wasm_input(x)) || 0n;
      },
      js_log(arg) {
        console.log(arg);
      },
      js_log_u64(arg) {
        console.log(arg);
      }
      //   printDec(arg) {
      //     process.stdout.write(arg);
      //   },
      //   printHex(arg) {
      //     process.stdout.write(arg.toString(16));
      //   },
      //   printSp() {
      //     process.stdout.write(' ');
      //   },
      //   printLn() {
      //     console.log();
      //   },
      //   c_log(arg) {
      //     // to compatible with c-wasm
      //     console.log('c_log: ', arg);
      //   },
    })
  };
  const { exports: exports$1 } = await WebAssembly.instantiate(module, adaptedImports);
  const memory = exports$1.memory || imports.env.memory;
  const adaptedExports = Object.setPrototypeOf(
    {
      asmain_local(rawreceipts, matched_event_offsets) {
        rawreceipts = __retain(
          __lowerTypedArray(Uint8Array, 4, 0, rawreceipts) || __notnull()
        );
        matched_event_offsets = __lowerTypedArray(Uint32Array, 5, 2, matched_event_offsets) || __notnull();
        try {
          return __liftTypedArray(
            Uint8Array,
            exports$1.asmain(rawreceipts, matched_event_offsets) >>> 0
          );
        } finally {
          __release(rawreceipts);
        }
      },
      asmain() {
        return __liftTypedArray(
          Uint8Array,
          exports$1.asmain() >>> 0
        );
      }
    },
    exports$1
  );
  function __liftString(pointer) {
    if (!pointer)
      return null;
    const end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1;
    const memoryU16 = new Uint16Array(memory.buffer);
    let start = pointer >>> 1;
    let string = "";
    while (end - start > 1024) {
      string += String.fromCharCode(
        ...memoryU16.subarray(start, start += 1024)
      );
    }
    return string + String.fromCharCode(...memoryU16.subarray(start, end));
  }
  function __liftTypedArray(constructor, pointer) {
    if (!pointer)
      return null;
    return new constructor(
      memory.buffer,
      __getU32(pointer + 4),
      __dataview.getUint32(pointer + 8, true) / constructor.BYTES_PER_ELEMENT
    ).slice();
  }
  function __lowerTypedArray(constructor, id, align, values) {
    if (values == null)
      return 0;
    const length = values.length;
    const buffer = exports$1.__pin(exports$1.__new(length << align, 1)) >>> 0;
    const header = exports$1.__new(12, id) >>> 0;
    __setU32(header + 0, buffer);
    __dataview.setUint32(header + 4, buffer, true);
    __dataview.setUint32(header + 8, length << align, true);
    new constructor(memory.buffer, buffer, length).set(values);
    exports$1.__unpin(buffer);
    return header;
  }
  const refcounts = /* @__PURE__ */ new Map();
  function __retain(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount)
        refcounts.set(pointer, refcount + 1);
      else
        refcounts.set(exports$1.__pin(pointer), 1);
    }
    return pointer;
  }
  function __release(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount === 1) {
        exports$1.__unpin(pointer);
        refcounts.delete(pointer);
      } else if (refcount) {
        refcounts.set(pointer, refcount - 1);
      } else {
        throw new Error(
          `invalid refcount '${refcount}' for reference '${pointer}'`
        );
      }
    }
  }
  function __notnull() {
    throw new TypeError("value must not be null");
  }
  let __dataview = new DataView(memory.buffer);
  function __setU32(pointer, value) {
    try {
      __dataview.setUint32(pointer, value, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      __dataview.setUint32(pointer, value, true);
    }
  }
  function __getU32(pointer) {
    try {
      return __dataview.getUint32(pointer, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      return __dataview.getUint32(pointer, true);
    }
  }
  return adaptedExports;
}
const instantiateWasm = async (wasmUint8Array) => {
  return instantiate(
    // @ts-expect-error TODO: fix this
    await (async () => {
      return globalThis.WebAssembly.compile(
        wasmUint8Array.buffer
      );
    })(),
    {}
  );
};

async function execute(zkGraphExecutable, execParams, isLocal = false, _enableLog = true) {
  const { zkgraphYaml } = zkGraphExecutable;
  const dsp = dspHub.getDSPByYaml(zkgraphYaml, { isLocal });
  if (!dsp)
    throw new DSPNotFound("Can't find DSP for this data source kind.");
  const prepareParams = await (dsp == null ? void 0 : dsp.toPrepareParams(execParams, "exec"));
  const dataPrep = await (dsp == null ? void 0 : dsp.prepareData(zkgraphYaml, prepareParams));
  return await executeOnDataPrep(zkGraphExecutable, dataPrep);
}
async function executeOnDataPrep(zkGraphExecutable, dataPrep, isLocal = false, _enableLog = true) {
  const { zkgraphYaml } = zkGraphExecutable;
  let input = new Input();
  const dsp = dspHub.getDSPByYaml(zkgraphYaml, { isLocal });
  if (!dsp)
    throw new DSPNotFound("Can't find DSP for this data source kind.");
  input = dsp.fillExecInput(input, zkgraphYaml, dataPrep);
  const [privateInputStr, publicInputStr] = [input.getPrivateInputStr(), input.getPublicInputStr()];
  return await executeOnInputs(zkGraphExecutable, privateInputStr, publicInputStr);
}
async function executeOnInputs(zkGraphExecutable, privateInputStr, publicInputStr) {
  const { wasmUint8Array } = zkGraphExecutable;
  if (!wasmUint8Array)
    throw new Error("wasmUint8Array is null");
  const mock = new ZKWASMMock();
  mock.set_private_input(privateInputStr);
  mock.set_public_input(publicInputStr);
  setupZKWasmMock(mock);
  const { asmain } = await instantiateWasm(wasmUint8Array).catch((error) => {
    throw error;
  });
  let stateU8a;
  try {
    stateU8a = asmain();
  } catch (e) {
    throw e;
  }
  return stateU8a;
}

async function proveInputGen(zkGraphExecutable, proveParams, isLocal = false, _enableLog = true) {
  const { zkgraphYaml } = zkGraphExecutable;
  const dsp = dspHub.getDSPByYaml(zkgraphYaml, { isLocal });
  if (!dsp)
    throw new DSPNotFound("Can't find DSP for this data source kind.");
  const prepareParams = await (dsp == null ? void 0 : dsp.toPrepareParams(proveParams, "prove"));
  const dataPrep = await (dsp == null ? void 0 : dsp.prepareData(zkgraphYaml, prepareParams));
  return proveInputGenOnDataPrep(zkGraphExecutable, dataPrep, isLocal);
}
function proveInputGenOnDataPrep(zkGraphExecutable, dataPrep, isLocal = false) {
  const { zkgraphYaml } = zkGraphExecutable;
  let input = new Input();
  const dsp = dspHub.getDSPByYaml(zkgraphYaml, { isLocal });
  if (!dsp)
    throw new DSPNotFound("Can't find DSP for this data source kind.");
  input = dsp.fillProveInput(input, zkgraphYaml, dataPrep);
  return [input.getPrivateInputStr(), input.getPublicInputStr()];
}

async function proveMock(zkGraphExecutable, privateInputStr, publicInputStr) {
  const { wasmUint8Array } = zkGraphExecutable;
  const mock = new ZKWASMMock();
  mock.set_private_input(privateInputStr);
  mock.set_public_input(publicInputStr);
  setupZKWasmMock(mock);
  const { zkmain } = await instantiateWasm(wasmUint8Array).catch((error) => {
    throw error;
  });
  try {
    zkmain();
  } catch (e) {
    if (e instanceof ZKGraphRequireFailed)
      return false;
    throw e;
  }
  return true;
}

function handleAxiosError(error) {
  var _a, _b, _c, _d, _e;
  let errMsg = "";
  let isRetry = false;
  switch (error.code) {
    case "ENOTFOUND":
      errMsg = `Can't connect to ${(_a = error.response) == null ? void 0 : _a.config.baseURL}`;
      break;
    case "ERR_BAD_RESPONSE":
      if (error.response) {
        switch (error.response.status) {
          case 500:
            errMsg = error.response.data;
            break;
          case 502:
            isRetry = true;
            break;
          default:
            errMsg = `ERR_BAD_RESPONSE: ${error.response.status} ${error.response.statusText}.`;
            break;
        }
        break;
      }
      break;
    case "ERR_BAD_REQUEST":
      errMsg = `ERR_BAD_REQUEST: ${(_b = error.response) == null ? void 0 : _b.status} ${(_c = error.response) == null ? void 0 : _c.statusText}.`;
      break;
    default:
      console.log("in handleAxiosError:");
      console.log(error);
      errMsg = `HTTP ERROR: ${(_d = error.response) == null ? void 0 : _d.status} ${(_e = error.response) == null ? void 0 : _e.statusText}.`;
      break;
  }
  return [errMsg, isRetry];
}

class EndPoint {
  url;
  isProtected;
  contentType = {};
  constructor(url, isProtected, contentType = {}) {
    this.url = url;
    this.isProtected = isProtected;
    this.contentType = contentType;
  }
}
var url = {
  postNewWasmImage: (zkwasmProverUrl) => new EndPoint(`${zkwasmProverUrl}/setup`, false),
  fetchConfiguredMD5: (zkwasmProverUrl) => new EndPoint(`${zkwasmProverUrl}/tasks?tasktype=Setup`, false),
  checkWasmImageStatus: (zkwasmProverUrl, md5, taskType = null) => new EndPoint(
    `${zkwasmProverUrl}/tasks?md5=${md5}${taskType ? `&tasktype=${taskType}` : ""}`,
    false
  ),
  deployWasmImageURL: (zkwasmProverUrl) => new EndPoint(`${zkwasmProverUrl}/deploy`, false, {
    "Content-Type": "application/json"
  }),
  proveWasmImageURL: (zkwasmProverUrl) => new EndPoint(`${zkwasmProverUrl}/prove`, false, {
    "Content-Type": "application/json"
  }),
  getTaskDetails: (zkwasmProverUrl, taskId) => new EndPoint(`${zkwasmProverUrl}/tasks?id=${taskId}`, false, {
    "Content-Type": "application/json"
  }),
  searchImageURL: (zkwasmProverUrl, md5) => new EndPoint(`${zkwasmProverUrl}/image?md5=${md5}`, false),
  getUserBalance: (zkwasmProverUrl, address) => new EndPoint(
    `${zkwasmProverUrl}/user?user_address=${address}`,
    false
  ),
  sendTXHash: (zkwasmProverUrl, _address) => new EndPoint(`${zkwasmProverUrl}/pay`, false, {
    "Content-Type": "application/json"
  }),
  uploadToPinata: (pinataEndpoint) => new EndPoint(`${pinataEndpoint}`, true)
};

async function zkwasm_prove(zkwasmProverUrl, user_privatekey, image_md5, public_inputs, private_inputs) {
  let isSetUpSuccess = true;
  const user_address = ethers.utils.computeAddress(user_privatekey).toLowerCase();
  const message = zkwasmServiceHelper.ZkWasmUtil.createProvingSignMessage({
    user_address: user_address.toLowerCase(),
    md5: image_md5.toUpperCase(),
    public_inputs,
    private_inputs
  });
  const wallet = new ethers.Wallet(user_privatekey);
  const signature = await wallet.signMessage(message);
  const req = JSON.stringify({
    user_address: user_address.toLowerCase(),
    md5: image_md5.toUpperCase(),
    public_inputs,
    private_inputs
    // signature,
  });
  const zkwasmHeaders = {
    "X-Eth-Address": user_address.toLowerCase(),
    "X-Eth-Signature": signature
  };
  const requestConfig = {
    method: "post",
    maxBodyLength: Infinity,
    url: url.proveWasmImageURL(zkwasmProverUrl).url,
    headers: {
      ...url.proveWasmImageURL(zkwasmProverUrl).contentType,
      ...zkwasmHeaders
    },
    data: req
  };
  let errorMessage = "";
  const response = await axios.request(requestConfig).catch((error) => {
    [errorMessage] = handleAxiosError(error);
    isSetUpSuccess = false;
  });
  return [response, isSetUpSuccess, errorMessage];
}

async function zkwasm_taskdetails(zkwasmProverUrl, taskId) {
  const requestConfig = {
    method: "get",
    maxBodyLength: Infinity,
    url: url.getTaskDetails(zkwasmProverUrl, taskId).url,
    headers: {
      ...url.getTaskDetails(zkwasmProverUrl).contentType
    }
  };
  let errorMessage = null;
  const response = await axios.request(requestConfig).catch((error) => {
    errorMessage = error;
  });
  return [response, errorMessage];
}
async function waitTaskStatus(zkwasmProverUrl, taskId, statuslist, interval, _timeout = 0) {
  return new Promise((resolve, reject) => {
    const checkStatus = async () => {
      const [response, error] = await zkwasm_taskdetails(zkwasmProverUrl, taskId);
      if (error !== null) {
        const [errMsg, isRetry] = handleAxiosError(error);
        if (isRetry) {
          console.log(errMsg, "Retry.");
          setTimeout(checkStatus, interval);
        } else {
          reject(errMsg);
        }
      } else {
        const status = response.data.result.data[0].status;
        let matched = false;
        for (const i in statuslist) {
          if (status === statuslist[i]) {
            matched = true;
            break;
          }
        }
        if (matched)
          resolve(response.data.result.data[0]);
        else
          setTimeout(checkStatus, interval);
      }
    };
    checkStatus();
  });
}
function millToHumanReadable(mill) {
  const min = Math.floor(mill / 6e4);
  const sec = mill % 6e4 / 1e3;
  return `${min} min ${sec} sec`;
}
function taskPrettyPrint(resData, prefix = "") {
  console.log(`${prefix}Task submit time: ${resData.submit_time}`);
  console.log(`${prefix}Process started: ${resData.process_started}`);
  console.log(`${prefix}Process finished: ${resData.process_finished}`);
  console.log(
    `${prefix}Pending time: ${millToHumanReadable(
      // @ts-expect-error TODO: fix this, it's incorrect, should new Date().getTime() or other
      new Date(resData.process_started) - new Date(resData.submit_time)
    )}`
  );
  console.log(
    `${prefix}Running time: ${millToHumanReadable(
      // @ts-expect-error TODO: fix this, it's incorrect, should new Date().getTime() or other
      new Date(resData.process_finished) - new Date(resData.process_started)
    )}`
  );
}

async function prove(zkGraphExecutable, privateInputStr, publicInputStr, zkwasmProverUrl, userPrivateKey, enableLog = true) {
  const result = {
    md5: null,
    taskId: null,
    errorMessage: null
  };
  const { wasmUint8Array } = zkGraphExecutable;
  const privateInputArray = privateInputStr.trim().split(" ");
  const publicInputArray = publicInputStr.trim().split(" ");
  const md5 = zkwasmServiceHelper.ZkWasmUtil.convertToMd5(wasmUint8Array).toUpperCase();
  result.md5 = md5;
  const [response, isSetUpSuccess, errorMessage] = await zkwasm_prove(
    zkwasmProverUrl,
    userPrivateKey,
    md5,
    publicInputArray,
    privateInputArray
  ).catch((error) => {
    throw error;
  });
  if (enableLog)
    console.log(`[*] IMAGE MD5: ${md5}`, "\n");
  if (isSetUpSuccess) {
    const taskId = response.data.result.id;
    result.taskId = taskId;
    result.errorMessage = errorMessage;
  }
  return result;
}
async function waitProve(zkwasmProverUrl, taskId, enableLog = true) {
  const result = {
    instances: null,
    batch_instances: null,
    proof: null,
    aux: null,
    md5: null,
    taskId: null
  };
  let loading;
  if (enableLog)
    loading = logLoadingAnimation();
  let taskDetails;
  try {
    taskDetails = await waitTaskStatus(
      zkwasmProverUrl,
      taskId,
      ["Done", "Fail", "DryRunFailed"],
      3e3,
      0
    ).catch((err) => {
      throw err;
    });
  } catch (error) {
    loading == null ? void 0 : loading.stopAndClear();
    throw error;
  }
  if (taskDetails.status === "Done") {
    if (enableLog) {
      loading == null ? void 0 : loading.stopAndClear();
      console.log("[+] PROVE SUCCESS!", "\n");
    }
    const instances = toHexStringBytes32Reverse(taskDetails.instances);
    const batch_instances = toHexStringBytes32Reverse(
      taskDetails.batch_instances
    );
    const proof = toHexStringBytes32Reverse(taskDetails.proof);
    const aux = toHexStringBytes32Reverse(taskDetails.aux);
    if (enableLog) {
      taskPrettyPrint(taskDetails, "[*] ");
      console.log();
    }
    result.instances = instances;
    result.batch_instances = batch_instances;
    result.proof = proof;
    result.aux = aux;
    result.taskId = taskId;
  } else {
    result.taskId = taskId;
    if (enableLog) {
      loading == null ? void 0 : loading.stopAndClear();
      console.log("[-] PROVE OR DRYRUN FAILED.", "\n");
    }
  }
  return result;
}

async function pinata_upload(wasmPath, mappingPath, yamlPath, pinataEndpoint, pinataJWT) {
  let isUploadSuccess = true;
  const fs = require("fs");
  const mappingFile = fs.createReadStream(mappingPath);
  const wasmFile = fs.createReadStream(wasmPath);
  const yamlFile = fs.createReadStream(yamlPath);
  const wasmU8A = new Uint8Array(fs.readFileSync(wasmPath));
  const yamlU8A = new Uint8Array(fs.readFileSync(yamlPath));
  const mergedArray = new Uint8Array(wasmU8A.length + yamlU8A.length);
  mergedArray.set(wasmU8A);
  mergedArray.set(yamlU8A, wasmU8A.length);
  const md5_merged = zkwasmServiceHelper.ZkWasmUtil.convertToMd5(mergedArray).toUpperCase();
  const directoryName = `zkgraph-md5-${md5_merged}`;
  const formData = new FormData();
  formData.append("file", mappingFile, {
    filepath: `${directoryName}/mapping.ts`
  });
  formData.append("file", wasmFile, {
    filepath: `${directoryName}/zkgraph.wasm`
  });
  formData.append("file", yamlFile, {
    filepath: `${directoryName}/zkgraph.yaml`
  });
  const metadata = JSON.stringify({
    name: directoryName
  });
  formData.append("pinataMetadata", metadata);
  const requestConfig = {
    method: "post",
    maxBodyLength: Infinity,
    url: url.uploadToPinata(pinataEndpoint).url,
    headers: {
      Authorization: `Bearer ${pinataJWT}`,
      ...formData.getHeaders()
    },
    data: formData
  };
  let errorMessage = "";
  const response = await axios.request(requestConfig).catch((error) => {
    [errorMessage] = handleAxiosError(error);
    isUploadSuccess = false;
  });
  return [response, isUploadSuccess, errorMessage];
}

async function upload(mappingPath, wasmPath, yamlPath, pinataEndpoint, pinataJWT) {
  {
    const [response, isUploadSuccess, errorMessage] = await pinata_upload(
      // userAddress,
      wasmPath,
      mappingPath,
      yamlPath,
      // zkGraphName,
      pinataEndpoint,
      pinataJWT
    ).catch((error) => {
      throw error;
    });
    return {
      response,
      isUploadSuccess,
      errorMessage
    };
  }
}

async function zkwasm_setup(ZkwasmProviderUrl, name, image_md5, image, user_privatekey, description_url, avator_url, circuit_size) {
  const user_address = ethers.utils.computeAddress(user_privatekey).toLowerCase();
  const message = zkwasmServiceHelper.ZkWasmUtil.createAddImageSignMessage({
    name,
    image_md5: image_md5.toLowerCase(),
    image,
    user_address,
    description_url,
    avator_url,
    circuit_size
  });
  const wallet = new ethers.Wallet(user_privatekey);
  const signature = await wallet.signMessage(message);
  const formData = new FormData();
  formData.append("name", name);
  formData.append("image_md5", image_md5.toLowerCase());
  formData.append("image", image);
  formData.append("user_address", user_address);
  formData.append("description_url", description_url);
  formData.append("avator_url", avator_url);
  formData.append("circuit_size", circuit_size);
  const zkwasmHeaders = {
    "X-Eth-Address": user_address,
    "X-Eth-Signature": signature
  };
  const requestConfig = {
    method: "post",
    maxBodyLength: Infinity,
    url: url.postNewWasmImage(ZkwasmProviderUrl).url,
    headers: {
      ...formData.getHeaders(),
      ...zkwasmHeaders
    },
    data: formData
  };
  let response;
  let errorMessage = "";
  let isRetry;
  const retry_time = 1;
  for (let i = 0; i < retry_time + 1; i++) {
    response = await axios.request(requestConfig).catch((error) => {
      [errorMessage, isRetry] = handleAxiosError(error);
      if (isRetry) ; else if (errorMessage === "Error: Image already exists!") {
        throw new ImageAlreadyExists(errorMessage);
      } else if (errorMessage.startsWith("Payment error")) {
        throw new PaymentError(errorMessage);
      } else {
        console.log(error.message);
      }
    });
    if (!isRetry)
      break;
    console.log(errorMessage, "retrying..");
  }
  return response;
}

async function zkwasm_imagetask(zkwasmProverUrl, md5, taskType) {
  const requestConfig = {
    method: "get",
    maxBodyLength: Infinity,
    url: url.checkWasmImageStatus(zkwasmProverUrl, md5.toUpperCase(), taskType).url,
    headers: {
      ...url.checkWasmImageStatus(zkwasmProverUrl, md5.toUpperCase(), taskType).contentType
    }
  };
  const response = await axios.request(requestConfig);
  return response;
}

async function setup(wasmName, zkGraphExecutable, circuitSize, userPrivateKey, ZkwasmProviderUrl, isLocal = false, enableLog = true) {
  const { wasmUint8Array } = zkGraphExecutable;
  let cirSz;
  if (circuitSize >= 18 && circuitSize <= 30) {
    cirSz = circuitSize;
  } else {
    cirSz = isLocal ? 20 : 22;
    if (enableLog) {
      console.warn(
        "[-] Warning: circuit size [",
        cirSz,
        "] was impractical, reset to default:",
        cirSz
      );
    }
  }
  if (!wasmUint8Array)
    throw new Error("wasmUint8Array is not defined");
  const md5 = zkwasmServiceHelper.ZkWasmUtil.convertToMd5(wasmUint8Array).toLowerCase();
  const image = createFileFromUint8Array(wasmUint8Array, wasmName);
  const description_url_encoded = "";
  const avator_url = "";
  const circuit_size = cirSz;
  if (enableLog)
    console.log(`[+] IMAGE MD5: ${md5}`, "\n");
  let taskId;
  await zkwasm_setup(
    ZkwasmProviderUrl,
    wasmName,
    // only use in zkwasm, can diff from local files
    md5,
    image,
    userPrivateKey,
    description_url_encoded,
    avator_url,
    circuit_size
  ).then(async (response) => {
    taskId = response.data.result.id;
    if (enableLog)
      console.log(`[+] SET UP TASK STARTED. TASK ID: ${taskId}`, "\n");
  }).catch(async (error) => {
    if (error instanceof ImageAlreadyExists) {
      let res = await zkwasm_imagetask(ZkwasmProviderUrl, md5, "Reset");
      if (res.data.result.total === 0)
        res = await zkwasm_imagetask(ZkwasmProviderUrl, md5, "Setup");
      taskId = res.data.result.data[0]._id.$oid;
      if (enableLog) {
        console.log(
          `[*] IMAGE ALREADY EXISTS. PREVIOUS SETUP TASK ID: ${taskId}`,
          "\n"
        );
      }
    } else {
      throw error;
    }
  });
}
async function waitSetup(ZkwasmProviderUrl, taskId, enableLog) {
  let loading;
  const result = { taskId: null, success: false };
  let taskDetails;
  let setupStatus;
  if (enableLog) {
    console.log(
      "[*] Please wait for image set up... (estimated: 1-5 min)",
      "\n"
    );
    loading = logLoadingAnimation();
    taskDetails = await waitTaskStatus(
      ZkwasmProviderUrl,
      taskId,
      ["Done", "Fail"],
      3e3,
      0
    );
    setupStatus = taskDetails.status;
    if (enableLog)
      loading.stopAndClear();
  }
  if (enableLog) {
    taskPrettyPrint(taskDetails, "[*] ");
    const taskStatus = setupStatus === "Done" ? "SUCCESS" : "FAILED";
    console.log(
      `[${taskStatus === "SUCCESS" ? "+" : "-"}] SET UP ${taskStatus}`,
      "\n"
    );
  }
  result.success = setupStatus === "Done";
  result.taskId = taskId;
  return result;
}

async function zkwasm_imagedetails(zkwasmProverUrl, md5) {
  const requestConfig = {
    method: "get",
    maxBodyLength: Infinity,
    url: url.searchImageURL(zkwasmProverUrl, md5.toUpperCase()).url,
    headers: {
      ...url.searchImageURL(zkwasmProverUrl, md5.toUpperCase()).contentType
    }
  };
  let errorMessage = null;
  const response = await axios.request(requestConfig).catch((error) => {
    errorMessage = error;
  });
  return [response, errorMessage];
}

async function publish(zkGraphExecutable, zkwasmProviderUrl, provider, ipfsHash, bountyRewardPerTrigger, signer, enableLog = true) {
  const imgCmt = await getImageCommitment(zkGraphExecutable, zkwasmProviderUrl);
  return publishByImgCmt(zkGraphExecutable, imgCmt, provider, ipfsHash, bountyRewardPerTrigger, signer, enableLog);
}
async function publishByImgCmt(zkGraphExecutable, imageCommitment, provider, ipfsHash, bountyRewardPerTrigger, signer, enableLog = true) {
  const { zkgraphYaml } = zkGraphExecutable;
  const dsp = dspHub.getDSPByYaml(zkgraphYaml, { isLocal: false });
  if (!dsp)
    throw new DSPNotFound("Can't find DSP for this data source kind.");
  const dspID = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(dsp.getLibDSPName()));
  const networkName = zkgraphYaml == null ? void 0 : zkgraphYaml.dataDestinations[0].network;
  const destinationContractAddress = zkgraphYaml == null ? void 0 : zkgraphYaml.dataDestinations[0].address;
  const factoryAddress = loadConfigByNetwork(zkgraphYaml, addressFactory, false);
  const factoryContract = new ethers.Contract(factoryAddress, abiFactory, provider).connect(signer);
  const tx = await factoryContract.registry(
    destinationContractAddress,
    AddressZero,
    bountyRewardPerTrigger,
    dspID,
    ipfsHash,
    imageCommitment.pointX,
    imageCommitment.pointY
  ).catch((_err) => {
    throw new GraphAlreadyExist("Duplicate zkGraph detected. Only publishing distinct zkGraphs is allowed.");
  });
  let loading;
  if (enableLog === true) {
    console.log("[*] Please wait for publish tx... (estimated: 30 sec)", "\n");
    loading = logLoadingAnimation();
  }
  const txReceipt = await tx.wait(1).catch((err) => {
    throw err;
  });
  if (enableLog === true) {
    loading == null ? void 0 : loading.stopAndClear();
    console.log("[+] ZKGRAPH PUBLISHED SUCCESSFULLY!", "\n");
    console.log(
      `[*] Transaction confirmed in block ${txReceipt.blockNumber} on ${networkName}`
    );
    console.log(`[*] Transaction hash: ${txReceipt.transactionHash}`, "\n");
  }
  return txReceipt.transactionHash;
}
function littleEndianToUint256(inputArray) {
  const reversedArray = inputArray.reverse();
  const hexString = `0x${reversedArray.map((byte) => byte.toString(16).padStart(2, "0")).join("")}`;
  return ethers.ethers.BigNumber.from(hexString);
}
async function getImageCommitment(zkGraphExecutable, zkwasmProviderUrl) {
  var _a;
  const { wasmUint8Array } = zkGraphExecutable;
  const md5 = zkwasmServiceHelper.ZkWasmUtil.convertToMd5(wasmUint8Array).toLowerCase();
  const deatails = await zkwasm_imagedetails(zkwasmProviderUrl, md5);
  const result = (_a = deatails[0]) == null ? void 0 : _a.data.result[0];
  if (result === null)
    throw new Error("Can't find zkWasm image details, please finish setup before publish.");
  const pointX = littleEndianToUint256(result.checksum.x);
  const pointY = littleEndianToUint256(result.checksum.y);
  return { pointX, pointY };
}

async function deposit(provider, signer, graphContractAddress, depositAmount, enableLog = true) {
  const graphContract = new ethers.Contract(graphContractAddress, graph_abi, provider).connect(signer);
  const tx = await graphContract.deposit(
    ethers.ethers.utils.parseEther(depositAmount),
    { value: ethers.ethers.utils.parseEther(depositAmount) }
  ).catch((err) => {
    throw err;
  });
  let loading;
  if (enableLog === true) {
    console.log("[*] Please wait for deposit tx... (estimated: 30 sec)", "\n");
    loading = logLoadingAnimation();
  }
  const txReceipt = await tx.wait(1).catch((err) => {
    throw err;
  });
  if (enableLog === true) {
    loading == null ? void 0 : loading.stopAndClear();
    console.log("[+] ZKGRAPH BOUNTY DEPOSIT COMPLETE!", "\n");
    console.log(
      `[*] Transaction confirmed in block ${txReceipt.blockNumber}`
    );
    console.log(`[*] Transaction hash: ${txReceipt.transactionHash}`, "\n");
  }
  return txReceipt.transactionHash;
}

async function verify(zkGraphExecutable, proofParams, jsonRpcProviderUrl) {
  const { zkgraphYaml } = zkGraphExecutable;
  const verifierContractAddress = loadConfigByNetwork(zkgraphYaml, AggregatorVerifierAddress, false);
  return await verifyProof(verifierContractAddress, proofParams, jsonRpcProviderUrl);
}
async function verifyProof(verifierContractAddress, proofParams, jsonRpcProviderUrl) {
  const proof = zkwasmServiceHelper.ZkWasmUtil.bytesToBigIntArray(proofParams.aggregate_proof);
  const instances = zkwasmServiceHelper.ZkWasmUtil.bytesToBigIntArray(proofParams.batch_instances);
  const aux = zkwasmServiceHelper.ZkWasmUtil.bytesToBigIntArray(proofParams.aux);
  const arg = zkwasmServiceHelper.ZkWasmUtil.bytesToBigIntArray(proofParams.instances);
  Web3EthContract.setProvider(jsonRpcProviderUrl);
  const contract = new Web3EthContract(AggregatorVerifierABI.abi, verifierContractAddress);
  let verificationResult = true;
  await contract.methods.verify(proof, instances, aux, [arg]).call().catch((err) => {
    if (err.message.startsWith("Returned error: execution reverted"))
      verificationResult = false;
    else
      throw err;
  });
  return verificationResult;
}
async function getVerifyProofParamsByTaskID(proveTaskId, ZkwasmProviderUrl) {
  const task = await waitTaskStatus(ZkwasmProviderUrl, proveTaskId, ["Done", "Fail"], 3e3, 0).catch((err) => {
    throw err;
  });
  if (task.status !== "Done")
    throw new ProveTaskNotReady("Prove task is not 'Done', can't verify");
  const proofParams = {
    aggregate_proof: task.proof,
    batch_instances: task.batch_instances,
    aux: task.aux,
    instances: task.instances
  };
  return proofParams;
}
async function getVerifyProofParamsByFile(_proofFileName) {
  throw new Error("not implemented.");
}

axiosRetry(axios, {
  retries: 5,
  retryDelay: (retryCount) => {
    return retryCount * 2e3;
  }
});
const ABI = [
  "function setup(string memory imageId, uint256 circuitSize) payable",
  "function prove(string memory imageId, string memory privateInput, string memory publicInput) payable"
];
class TaskDispatch {
  queryAPI;
  feeInWei;
  dispatcherContract;
  constructor(queryAPI, contractAddress, feeInWei, provider, signer) {
    this.queryAPI = queryAPI;
    this.feeInWei = feeInWei;
    this.dispatcherContract = new ethers.ethers.Contract(contractAddress, ABI, provider).connect(signer);
  }
  /**
     * Query task id by txhash.
     */
  async queryTask(txhash) {
    var _a, _b;
    let res;
    const request = async () => {
      var _a2;
      const response = await axios.get(`${this.queryAPI}/task?txhash=${txhash}`);
      const data = response.data;
      if (((_a2 = data.task) == null ? void 0 : _a2.status) === "submitted") {
        res = data;
        return true;
      }
      return false;
    };
    await utils$2.polling(request, 1e3);
    if (!((_a = res == null ? void 0 : res.task) == null ? void 0 : _a.id) && ((_b = res == null ? void 0 : res.task) == null ? void 0 : _b.status) === "submitted")
      throw new TDNoTaskFound("No corresponding task found for the transaction");
    return res;
  }
  /**
     * Setup wasm iamge.
     * @param {string} imageId
     * @param {number} circuitSize
     * @returns {Promise<ethers.ContractTransaction>}
     */
  async setup(imageId, circuitSize) {
    const tx = await this.dispatcherContract.setup(imageId, circuitSize, {
      value: this.feeInWei
    });
    return tx;
  }
  /**
     * Prove task.
     * @param {string} imageId
     * @param {string} privateInput
     * @param {string} publicInput
     * @returns {Promise<ethers.ContractTransaction>}
     */
  async prove(imageId, privateInput, publicInput) {
    const tx = await this.dispatcherContract.prove(imageId, privateInput, publicInput, {
      value: this.feeInWei
    });
    return tx;
  }
}

async function zkwasm_deploy(chain_id, user_privatekey, image_md5, zkwasmProverUrl) {
  let isDeploySuccess = true;
  const address = ethers.utils.computeAddress(user_privatekey).toLowerCase();
  const wallet = new ethers.Wallet(user_privatekey);
  const message = JSON.stringify({
    user_address: address,
    md5: image_md5,
    chain_id
  });
  const signature = await wallet.signMessage(message);
  const requestData = JSON.stringify({
    user_address: address,
    md5: image_md5,
    chain_id,
    signature
  });
  const requestConfig = {
    method: "post",
    maxBodyLength: Infinity,
    url: url.deployWasmImageURL(zkwasmProverUrl).url,
    data: requestData,
    headers: {
      "Content-Type": url.deployWasmImageURL(zkwasmProverUrl).contentType["Content-Type"]
    }
  };
  let errorMessage = "";
  const response = await axios.request(requestConfig).catch((error) => {
    [errorMessage] = handleAxiosError(error);
    isDeploySuccess = false;
  });
  return [response, isDeploySuccess, errorMessage];
}

exports.DataPrep = DataPrep;
exports.DataSourcePlugin = DataSourcePlugin;
exports.ETHDSP = index;
exports.Error = error;
exports.Input = Input;
exports.TaskDispatch = TaskDispatch;
exports.ZkGraphYaml = ZkGraphYaml;
exports.constants = constants;
exports.deposit = deposit;
exports.dspHub = dspHub;
exports.execute = execute;
exports.executeOnDataPrep = executeOnDataPrep;
exports.executeOnInputs = executeOnInputs;
exports.getBlockByNumber = getBlockByNumber;
exports.getImageCommitment = getImageCommitment;
exports.getRawReceipts = getRawReceipts;
exports.getVerifyProofParamsByFile = getVerifyProofParamsByFile;
exports.getVerifyProofParamsByTaskID = getVerifyProofParamsByTaskID;
exports.instantiateWasm = instantiateWasm;
exports.prove = prove;
exports.proveInputGen = proveInputGen;
exports.proveInputGenOnDataPrep = proveInputGenOnDataPrep;
exports.proveMock = proveMock;
exports.publish = publish;
exports.publishByImgCmt = publishByImgCmt;
exports.setup = setup;
exports.upload = upload;
exports.utils = utils$1;
exports.verify = verify;
exports.verifyProof = verifyProof;
exports.waitProve = waitProve;
exports.waitSetup = waitSetup;
exports.waitTaskStatus = waitTaskStatus;
exports.zkwasm_deploy = zkwasm_deploy;
exports.zkwasm_imagedetails = zkwasm_imagedetails;
exports.zkwasm_prove = zkwasm_prove;
exports.zkwasm_setup = zkwasm_setup;
