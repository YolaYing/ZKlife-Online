import fs from 'fs';
import { BytesLike, providers, ethers } from 'ethers';
import * as axios from 'axios';
import { AxiosResponse } from 'axios';

declare class Input {
    inputStr: string[];
    static privateId: number;
    static publicId: number;
    getPrivateInputStr(): string;
    getPublicInputStr(): string;
    formatIntInput(input: number): string;
    formatHexStringInput(input: string): string;
    formatVarLenInput(input: string): string;
    addInt(input: number, isPublic?: boolean): void;
    addHexString(input: string, isPublic?: boolean): void;
    addVarLenHexString(input: string, isPublic?: boolean): void;
    addVarLenHexStringArray(input: string, isPublic?: boolean): void;
}

/**
 * Null or whatever
 */
type Nullable<T> = T | null | undefined;

/**
 * Object value null or whatever
 */
type NullableObject<T extends object> = {
    [P in keyof T]: Nullable<T[P]>;
};
/**
 * Object value null or whatever with keys
 * @example NullableObjectWithKeys<Record<'a' | 'b', string>, 'a'>
 */
type NullableObjectWithKeys<T extends object, Key extends keyof T> = {
    [P in keyof T]: P extends Key ? Nullable<T[P]> : T[P];
};
/**
 * Array value null or whatever with keys
 */
type KeyofToArray<T extends object> = keyof T extends never ? [] : (keyof T)[];

type DataSourceKind = 'ethereum' | 'offchain';
declare class DataSource {
    kind: DataSourceKind;
    constructor(kind: DataSourceKind);
    getSignificantKeys(): any;
    healthCheck(): void;
}
declare class Mapping {
    language: string;
    file: string;
    handler: string;
    constructor(language: string, file: string, handler: string);
    static from_v_0_0_2(yamlMapping: {
        language: string;
        file: string;
        handler: string;
    }): Mapping;
    static from_v_0_0_1(_yamlMapping: {
        language: string;
        file: string;
        handler: string;
    }): null;
}

declare class OffchainDataSource extends DataSource {
    type: any;
    constructor(kind: any, type: any);
    getSignificantKeys(): any[];
    static from_v_0_0_2(yamlOffDS: {
        kind: any;
        type: any;
    }): OffchainDataSource;
    static from_v_0_0_1(_yamlOffDS: any): void;
    static healthCheck(yamlOffDS: {
        kind: string;
        type: string;
    }): void;
}

declare class ZkGraphYaml {
    specVersion: string;
    apiVersion: string;
    description: string;
    repository: string;
    dataSources: any[];
    dataDestinations: any[];
    mapping: Mapping;
    name: string;
    constructor(specVersion: string, apiVersion: string, name: string, description: string, repository: any, dataSources: any[], dataDestinations: any[], mapping: Mapping);
    static from_v_0_0_2(yaml: any): ZkGraphYaml;
    static fromYaml(yaml: any): ZkGraphYaml;
    static fromYamlContent(yamlContent: string): ZkGraphYaml;
    static fromYamlPath(yamlPath: fs.PathOrFileDescriptor): ZkGraphYaml | undefined;
    static from_v_0_0_1(_yaml: any): ZkGraphYaml;
    getSignificantKeys(isSource: boolean): any[];
    getFilteredSourcesByKind(kind: DataSourceKind): OffchainDataSource[];
    static healthCheck(yaml: any): void;
}

declare class DataPrep {
}
declare abstract class DataSourcePlugin<EP extends object, PP extends object, PRP extends object, DP extends object> {
    abstract getLibDSPName(): string;
    abstract prepareData(zkgraphYaml: ZkGraphYaml, prepareParams: PRP): Promise<DP>;
    abstract fillExecInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: DP): Input;
    abstract fillProveInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: DP): Input;
    abstract toProveDataPrep(execDataPrep: DP, execResult: any): DP;
    abstract execParams: KeyofToArray<EP>;
    toExecParams(params: Record<string, any>): EP;
    abstract proveParams: KeyofToArray<PP>;
    toProveParams(params: Record<string, any>): PP;
    toPrepareParamsFromExecParams(execParams: EP): Promise<PRP>;
    toPrepareParamsFromProveParams(proveParams: PP): Promise<PRP>;
    abstract toPrepareParams(params: EP, type: 'exec'): Promise<PRP>;
    abstract toPrepareParams(params: PP, type: 'prove'): Promise<PRP>;
    abstract toPrepareParams(params: EP | PP, type: 'exec' | 'prove'): Promise<PRP>;
}

interface DSPHubForeignKeys {
    isLocal?: boolean;
}
declare class DSPHub {
    hub: Map<string, DataSourcePlugin<object, object, object, object>>;
    /**
     * @param {string} primaryKey yaml.dataSources[i].kind
     * @param {object} foreignKeys {"isLocal": boolean}
     * @returns Combined Key String: Better to be human readable
     */
    toHubKey(primaryKey: string, foreignKeys: DSPHubForeignKeys): string;
    toHubKeyByYaml(zkgraphYaml: ZkGraphYaml, foreignKeys: DSPHubForeignKeys): string;
    toPrimaryKey(sigKeys: any[]): string;
    setDSP(primaryKey: string, foreignKeys: DSPHubForeignKeys, dsp: InstanceType<typeof DataSourcePlugin<any, any, any, any>>): void;
    getDSP(primaryKey: string, foreignKeys: DSPHubForeignKeys): InstanceType<typeof DataSourcePlugin> | undefined;
    getDSPByYaml(zkgraphYaml: ZkGraphYaml, foreignKeys: DSPHubForeignKeys): DataSourcePlugin<object, object, object, object> | undefined;
}
/**
 * Global DSP Hub
 */
declare const dspHub: DSPHub;

interface Hexable {
    toHexString(): string;
}

declare class EthereumDataPrep extends DataPrep {
    blockPrepMap: any;
    blocknumberOrder: any;
    latestBlockhash: any;
    expectedStateStr: any;
    constructor(blockPrepMap: Map<any, any>, blocknumberOrder: number[], latestBlockhash: string, expectedStateStr: string);
}
declare class AccountPrep {
    address: any;
    rlpNode: any;
    accountProof: any;
    slots: Map<any, any>;
    constructor(address: any, rlpNode: any, accountProof: any);
    addSlot(key: any, value: any, storageProof: any /** string[] */): void;
    getSlot(key: any): any;
    hashSlot(key: any): boolean;
    addFromStorageProofList(storageProofList: any[]): void;
}
declare class BlockPrep {
    number: any;
    rlpHeader: any;
    accounts: Map<string, AccountPrep>;
    rlpreceipts: any[];
    constructor(blocknum: number | bigint | BytesLike | Hexable, rlpHeader: string);
    addAccount(address: string, rlpAccount: string, accountProof: any): void;
    getAccount(address: string): AccountPrep | undefined;
    hasAccount(address: string): boolean;
    addFromGetProofResult(ethproof: {
        address: any;
        accountProof: any;
        storageProof: any;
    }, accountRLP?: string | null): void;
    addRLPReceipts(rlpReceiptList: any[]): void;
    getRLPReceipts(): any[];
}

interface EthereumDSPPrepareParams {
    provider: providers.JsonRpcProvider;
    latestBlocknumber: number;
    latestBlockhash: string;
    expectedStateStr: string;
}
interface EthereumDSPExecParams {
    provider: providers.JsonRpcProvider;
    blockId: string;
}
interface EthereumDSPProveParams {
    provider: providers.JsonRpcProvider;
    blockId: string;
    expectedStateStr: string;
}
declare class EthereumDataSourcePlugin extends DataSourcePlugin<EthereumDSPExecParams, EthereumDSPProveParams, EthereumDSPPrepareParams, EthereumDataPrep> {
    getLibDSPName(): string;
    prepareData(zkgraphYaml: ZkGraphYaml, prepareParams: EthereumDSPPrepareParams): Promise<EthereumDataPrep>;
    fillExecInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: EthereumDataPrep): any;
    fillProveInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: EthereumDataPrep): Input;
    toProveDataPrep(execDataPrep: EthereumDataPrep, execResult: string): EthereumDataPrep;
    execParams: KeyofToArray<EthereumDSPExecParams>;
    proveParams: KeyofToArray<EthereumDSPProveParams>;
    toPrepareParams(params: EthereumDSPExecParams, type: 'exec'): Promise<EthereumDSPPrepareParams>;
    toPrepareParams(params: EthereumDSPProveParams, type: 'prove'): Promise<EthereumDSPPrepareParams>;
}

type index_EthereumDSPExecParams = EthereumDSPExecParams;
type index_EthereumDSPPrepareParams = EthereumDSPPrepareParams;
type index_EthereumDSPProveParams = EthereumDSPProveParams;
type index_EthereumDataPrep = EthereumDataPrep;
declare const index_EthereumDataPrep: typeof EthereumDataPrep;
type index_EthereumDataSourcePlugin = EthereumDataSourcePlugin;
declare const index_EthereumDataSourcePlugin: typeof EthereumDataSourcePlugin;
declare namespace index {
  export { type index_EthereumDSPExecParams as EthereumDSPExecParams, type index_EthereumDSPPrepareParams as EthereumDSPPrepareParams, type index_EthereumDSPProveParams as EthereumDSPProveParams, index_EthereumDataPrep as EthereumDataPrep, index_EthereumDataSourcePlugin as EthereumDataSourcePlugin };
}

declare class EthereumLocalDataSourcePlugin extends DataSourcePlugin<{}, {}, {}, {}> {
    prepareData(zkgraphYaml: ZkGraphYaml, prepareParams: Record<string, any>): Promise<any>;
    fillExecInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: {}): Input;
    fillProveInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: {}): Input;
    toProveDataPrep(execDataPrep: any, execResult: any): {};
    execParams: KeyofToArray<{}>;
    proveParams: KeyofToArray<{}>;
    getLibDSPName(): string;
    toPrepareParams(params: {}, type: 'exec'): Promise<{}>;
    toPrepareParams(params: {}, type: 'prove'): Promise<{}>;
    toPrepareParams(params: {}, type: 'exec' | 'prove'): Promise<{}>;
}

interface EthereumOffchainDPDataPrep {
    blockPrepMap: Map<number, BlockPrep>;
    blocknumberOrder: any[];
    latestBlockhash: string;
    offchainData: any;
    expectedStateStr: string;
}
interface EthereumOffchainDSPPrepareParams {
    provider: providers.JsonRpcProvider;
    latestBlocknumber: number;
    latestBlockhash: string;
    offchainData: any;
    expectedStateStr: string;
}
interface EthereumOffchainDSPExecParams {
    provider: providers.JsonRpcProvider;
    blockId: string;
    offchainData: any;
}
interface EthereumOffchainDSPProveParams {
    provider: providers.JsonRpcProvider;
    blockId: string;
    offchainData: any;
    expectedStateStr: string;
}
declare class EthereumOffchainDP extends DataPrep {
    blockPrepMap: any;
    blocknumberOrder: any;
    latestBlockhash: any;
    offchainData: any;
    expectedStateStr: any;
    constructor(blockPrepMap: any, blocknumberOrder: any, latestBlockhash: any, offchainData: any, expectedStateStr: any);
}
declare class EthereumOffchainDSP extends DataSourcePlugin<EthereumOffchainDSPExecParams, EthereumOffchainDSPProveParams, EthereumOffchainDSPPrepareParams, EthereumOffchainDPDataPrep> {
    getLibDSPName(): string;
    prepareData(zkgraphYaml: ZkGraphYaml, prepareParams: EthereumOffchainDSPPrepareParams): Promise<EthereumOffchainDP>;
    fillExecInput(input: Input, zkgraphYaml: ZkGraphYaml, dataPrep: EthereumOffchainDPDataPrep): Input;
    fillProveInput(input: any, zkgraphYaml: ZkGraphYaml, dataPrep: EthereumOffchainDPDataPrep): any;
    toProveDataPrep(execDataPrep: EthereumOffchainDPDataPrep, execResult: string): EthereumOffchainDPDataPrep;
    execParams: KeyofToArray<EthereumOffchainDSPExecParams>;
    proveParams: KeyofToArray<EthereumOffchainDSPProveParams>;
    toPrepareParams(params: EthereumOffchainDSPExecParams, type: 'exec'): Promise<EthereumOffchainDSPPrepareParams>;
    toPrepareParams(params: EthereumOffchainDSPProveParams, type: 'prove'): Promise<EthereumOffchainDSPPrepareParams>;
}

declare let hasDebugOnlyFunc: boolean;
declare const instantiateWasm: (wasmUint8Array: Uint8Array) => Promise<any>;

interface ZkGraphExecutable {
    wasmUint8Array: Uint8Array;
    zkgraphYaml: ZkGraphYaml;
}

/**
 * Execute the given zkGraphExecutable in the context of execParams
 * @param {object} zkGraphExecutable {'zkgraphYaml': zkgraphYaml}
 * @param {object} execParams
 * @param {boolean} isLocal
 * @param {boolean} enableLog
 * @returns {Uint8Array} - execution result (aka. zkgraph state)
 */
declare function execute(zkGraphExecutable: ZkGraphExecutable, execParams: Record<string, any>, isLocal?: boolean, _enableLog?: boolean): Promise<Uint8Array>;
/**
 *
 * @param {object} zkGraphExecutable
 * @param {DataPrep} dataPrep
 * @param {boolean} isLocal
 * @param {boolean} enableLog
 * @returns
 */
declare function executeOnDataPrep(zkGraphExecutable: ZkGraphExecutable, dataPrep: DataPrep, isLocal?: boolean, _enableLog?: boolean): Promise<Uint8Array>;
/**
 *
 * @param {object} zkGraphExecutable
 * @param {string} privateInputStr
 * @param {string} publicInputStr
 * @returns
 */
declare function executeOnInputs(zkGraphExecutable: ZkGraphExecutable, privateInputStr: string, publicInputStr: string): Promise<Uint8Array>;

/**
 * Generate the private and public inputs in hex string format
 * @param {string} yamlContent
 * @param {object} proveParams {"xx": xx}
 * @param {boolean} isLocal
 * @param {boolean} enableLog
 * @returns {[string, string]} - private input string, public input string
 */
declare function proveInputGen(zkGraphExecutable: NullableObjectWithKeys<ZkGraphExecutable, 'wasmUint8Array'>, proveParams: Record<string, any>, isLocal?: boolean, _enableLog?: boolean): Promise<[string, string]>;
declare function proveInputGenOnDataPrep(zkGraphExecutable: NullableObjectWithKeys<ZkGraphExecutable, 'wasmUint8Array'>, dataPrep: DataPrep, isLocal?: boolean): [string, string];

/**
 * Mock the zkwasm proving process for pre-test purpose.
 * @param {object} zkGraphExecutable
 * @param {string} privateInputStr
 * @param {string} publicInputStr
 * @returns {boolean} - the mock testing result
 */
declare function proveMock(zkGraphExecutable: NullableObjectWithKeys<ZkGraphExecutable, 'zkgraphYaml'>, privateInputStr: string, publicInputStr: string): Promise<boolean>;

/**
 * Submit prove task to a given zkwasm and return the proof details.
 * @param {object} zkGraphExecutable
 * @param {string} privateInputStr - the packed private input in hex string
 * @param {string} publicInputStr - the packed public input in hex string
 * @param {string} zkwasmProverUrl - the url of the zkwasm prover
 * @param {string} userPrivateKey - the acct for sign&submi prove task to zkwasm
 * @param {boolean} enableLog - enable logging or not
 * @returns {object} - proof task details in json
 */
declare function prove(zkGraphExecutable: NullableObjectWithKeys<ZkGraphExecutable, 'zkgraphYaml'>, privateInputStr: string, publicInputStr: string, zkwasmProverUrl: string, userPrivateKey: string, enableLog?: boolean): Promise<{
    md5: Nullable<string>;
    taskId: Nullable<string>;
    errorMessage: Nullable<string>;
}>;
declare function waitProve(zkwasmProverUrl: string, taskId: string, enableLog?: boolean): Promise<{
    instances: Nullable<string>;
    batch_instances: Nullable<string>;
    proof: Nullable<string>;
    aux: Nullable<string>;
    md5: Nullable<string>;
    taskId: Nullable<string>;
}>;

/**
 * Upload the given zkgraph {$mappingPath, $yamlPath} to ipfs
 * @param {string} mappingPath
 * @param {string} wasmPath
 * @param {string} yamlPath
 * @param {string} userAddress
 * @param {string} pinataEndpoint
 * @param {string} pinataJWT
 * @returns {boolean} - the upload result
 */
declare function upload(mappingPath: string, wasmPath: string, yamlPath: string, pinataEndpoint: string, pinataJWT: string): Promise<{
    response: axios.AxiosResponse<any, any>;
    isUploadSuccess: boolean;
    errorMessage: string;
} | {
    response?: undefined;
    isUploadSuccess?: undefined;
    errorMessage?: undefined;
}>;

/**
 * Set up zkwasm image with given wasm file.
 * @param {string} wasmName
 * @param {string} wasmUint8Array
 * @param {number} circuitSize
 * @param {string} userPrivateKey
 * @param {string} ZkwasmProviderUrl
 * @param {boolean} isLocal
 * @param {boolean} enableLog
 * @returns {{string, string, boolean}} - {'md5': md5, 'taskId': taskId, 'success': success}
 */
declare function setup(wasmName: string, zkGraphExecutable: NullableObjectWithKeys<ZkGraphExecutable, 'zkgraphYaml'>, circuitSize: number, userPrivateKey: string, ZkwasmProviderUrl: string, isLocal?: boolean, enableLog?: boolean): Promise<void>;
declare function waitSetup(ZkwasmProviderUrl: string, taskId: string, enableLog: boolean): Promise<{
    taskId: string | null;
    success: boolean;
}>;

/**
 * Publish and register zkGraph onchain.
 * @param {object} zkGraphExecutable {wasmUint8Array, zkgraphYaml}
 * @param {string} zkwasmProviderUrl - the zkWasm prover rpc url
 * @param {providers.JsonRpcProvider} provider - the provider of the target network
 * @param {string} ipfsHash - the ipfs hash of the zkGraph
 * @param {number} bountyRewardPerTrigger - the bounty reward per trigger in ETH
 * @param {object} signer - the acct for sign tx
 * @param {boolean} enableLog - enable logging or not
 * @returns {string} - transaction hash of the publish transaction if success, empty string otherwise
 */
declare function publish(zkGraphExecutable: ZkGraphExecutable, zkwasmProviderUrl: string, provider: providers.JsonRpcProvider, ipfsHash: string, bountyRewardPerTrigger: number, signer: ethers.Wallet | ethers.providers.Provider | string, enableLog?: boolean): Promise<any>;
/**
 * Publish and register zkGraph onchain, with code hash provided.
 * @param {object} zkGraphExecutable {zkgraphYaml}
 * @param {providers.JsonRpcProvider} provider - the provider of the target network
 * @param {string} ipfsHash - the ipfs hash of the zkGraph
 * @param {number} bountyRewardPerTrigger - the bounty reward per trigger in ETH
 * @param {object} signer - the acct for sign tx
 * @param {boolean} enableLog - enable logging or not
 * @returns {string} - transaction hash of the publish transaction if success, empty string otherwise
 */
declare function publishByImgCmt(zkGraphExecutable: ZkGraphExecutable, imageCommitment: {
    pointX: ethers.BigNumber;
    pointY: ethers.BigNumber;
}, provider: providers.JsonRpcProvider, ipfsHash: string, bountyRewardPerTrigger: number, signer: ethers.Wallet | ethers.providers.Provider | string, enableLog?: boolean): Promise<any>;
/**
 *
 * @param {object} zkGraphExecutable {wasmUint8Array}
 * @param zkGraphExecutable
 * @param {string} zkwasmProviderUrl - the zkWasm prover rpc url
 * @returns
 */
declare function getImageCommitment(zkGraphExecutable: ZkGraphExecutable, zkwasmProviderUrl: string): Promise<{
    pointX: ethers.BigNumber;
    pointY: ethers.BigNumber;
}>;

/**
 * Publish and register zkGraph onchain.
 * @param {providers.JsonRpcProvider} provider - the provider of the target network
 * @param {object} signer - the acct for sign tx
 * @param {string} graphContractAddress - the deployed verification contract address
 * @param {number} depositAmount - the deposit amount in ETH
 * @param {boolean} enableLog - enable logging or not
 * @returns {string} - transaction hash of the publish transaction if success, empty string otherwise
 */
declare function deposit(provider: providers.JsonRpcProvider, signer: ethers.Wallet | ethers.providers.Provider | string, graphContractAddress: string, depositAmount: string, enableLog?: boolean): Promise<any>;

interface VerifyProofParams {
    aggregate_proof: Uint8Array;
    batch_instances: Uint8Array;
    aux: Uint8Array;
    instances: Uint8Array;
}
declare function verify(zkGraphExecutable: NullableObject<ZkGraphExecutable>, proofParams: VerifyProofParams, jsonRpcProviderUrl: string): Promise<boolean>;
/**
 * Verify zk proof with eth call.
 * @param proofParams
 * @param verifierContractAddress
 * @param jsonRpcProviderUrl
 * @returns
 */
declare function verifyProof(verifierContractAddress: string, proofParams: VerifyProofParams, jsonRpcProviderUrl: string): Promise<boolean>;
declare function getVerifyProofParamsByTaskID(proveTaskId: string, ZkwasmProviderUrl: string): Promise<VerifyProofParams>;
declare function getVerifyProofParamsByFile(_proofFileName: string): Promise<void>;

declare function getRawReceipts(ethersProvider: providers.JsonRpcProvider, blockid: string | number, useDebugRPC?: boolean): Promise<any>;
declare function getBlockByNumber(ethersProvider: providers.JsonRpcProvider, blockNumber: number): Promise<any>;

declare class ZKGraphRequireFailed extends Error {
    constructor(message: string | undefined);
}
declare class ImageAlreadyExists extends Error {
    constructor(message: string | undefined);
}
declare class ProveTaskNotReady extends Error {
    constructor(message: string | undefined);
}
declare class PaymentError extends Error {
    constructor(message: string | undefined);
}
declare class YamlInvalidFormat extends Error {
    constructor(message: string | undefined);
}
declare class YamlHealthCheckFailed extends Error {
    constructor(message: string | undefined);
}
declare class YamlNotSupported extends Error {
    constructor(message: string | undefined);
}
declare class TDNoTaskFound extends Error {
    constructor(message: string | undefined);
}
declare class GraphAlreadyExist extends Error {
    constructor(message: string | undefined);
}
declare class DSPNotFound extends Error {
    constructor(message: string | undefined);
}
declare class BlockNotFound extends Error {
    constructor(message: string | undefined);
}
declare class OldBlockNumber extends Error {
    constructor(message: string | undefined);
}

type error_BlockNotFound = BlockNotFound;
declare const error_BlockNotFound: typeof BlockNotFound;
type error_DSPNotFound = DSPNotFound;
declare const error_DSPNotFound: typeof DSPNotFound;
type error_GraphAlreadyExist = GraphAlreadyExist;
declare const error_GraphAlreadyExist: typeof GraphAlreadyExist;
type error_ImageAlreadyExists = ImageAlreadyExists;
declare const error_ImageAlreadyExists: typeof ImageAlreadyExists;
type error_OldBlockNumber = OldBlockNumber;
declare const error_OldBlockNumber: typeof OldBlockNumber;
type error_PaymentError = PaymentError;
declare const error_PaymentError: typeof PaymentError;
type error_ProveTaskNotReady = ProveTaskNotReady;
declare const error_ProveTaskNotReady: typeof ProveTaskNotReady;
type error_TDNoTaskFound = TDNoTaskFound;
declare const error_TDNoTaskFound: typeof TDNoTaskFound;
type error_YamlHealthCheckFailed = YamlHealthCheckFailed;
declare const error_YamlHealthCheckFailed: typeof YamlHealthCheckFailed;
type error_YamlInvalidFormat = YamlInvalidFormat;
declare const error_YamlInvalidFormat: typeof YamlInvalidFormat;
type error_YamlNotSupported = YamlNotSupported;
declare const error_YamlNotSupported: typeof YamlNotSupported;
type error_ZKGraphRequireFailed = ZKGraphRequireFailed;
declare const error_ZKGraphRequireFailed: typeof ZKGraphRequireFailed;
declare namespace error {
  export { error_BlockNotFound as BlockNotFound, error_DSPNotFound as DSPNotFound, error_GraphAlreadyExist as GraphAlreadyExist, error_ImageAlreadyExists as ImageAlreadyExists, error_OldBlockNumber as OldBlockNumber, error_PaymentError as PaymentError, error_ProveTaskNotReady as ProveTaskNotReady, error_TDNoTaskFound as TDNoTaskFound, error_YamlHealthCheckFailed as YamlHealthCheckFailed, error_YamlInvalidFormat as YamlInvalidFormat, error_YamlNotSupported as YamlNotSupported, error_ZKGraphRequireFailed as ZKGraphRequireFailed };
}

declare function waitTaskStatus(zkwasmProverUrl: any, taskId: any, statuslist: {
    [x: string]: any;
}, interval: number | undefined, _timeout?: number): Promise<any>;

interface QueryTaskResponse {
    task?: {
        id?: string;
        type: 'setup' | 'prove';
        status: 'processing' | 'submitted';
    };
}
declare class TaskDispatch {
    queryAPI: string;
    feeInWei: ethers.BigNumber;
    dispatcherContract: ethers.Contract;
    constructor(queryAPI: string, contractAddress: string, feeInWei: ethers.BigNumber, provider: providers.JsonRpcProvider, signer: ethers.Wallet | ethers.providers.Provider | string);
    /**
       * Query task id by txhash.
       */
    queryTask(txhash: string): Promise<QueryTaskResponse>;
    /**
       * Setup wasm iamge.
       * @param {string} imageId
       * @param {number} circuitSize
       * @returns {Promise<ethers.ContractTransaction>}
       */
    setup(imageId: string, circuitSize: number): Promise<any>;
    /**
       * Prove task.
       * @param {string} imageId
       * @param {string} privateInput
       * @param {string} publicInput
       * @returns {Promise<ethers.ContractTransaction>}
       */
    prove(imageId: string, privateInput: string, publicInput: string): Promise<any>;
}

declare function zkwasm_setup(ZkwasmProviderUrl: string, name: string, image_md5: string, image: any, user_privatekey: string, description_url: string, avator_url: string, circuit_size: number): Promise<AxiosResponse<any, any>>;

declare function zkwasm_prove(zkwasmProverUrl: string, user_privatekey: string, image_md5: string, public_inputs: string[], private_inputs: string[]): Promise<[AxiosResponse<any, any>, boolean, string]>;

declare function zkwasm_deploy(chain_id: string, user_privatekey: string, image_md5: string, zkwasmProverUrl: string): Promise<[AxiosResponse<any, any>, boolean, string]>;

declare function zkwasm_imagedetails(zkwasmProverUrl: string, md5: string): Promise<(void | axios.AxiosResponse<any, any> | null)[]>;

/**
 * Convert hex string to Uint8Array
 * @param hexString
 * @returns
 */
declare function fromHexString(hexString: string): Uint8Array;
/**
 * Convert Uint8Array to hex string
 * @param bytes
 * @returns
 */
declare function toHexString(bytes: string | Uint8Array): string;
/**
 * Reverse Uint8Array to string
 * @param arr
 * @returns
 */
declare function toHexStringBytes32Reverse(arr: Uint8Array): string;
declare function areEqualArrays(first: Uint8Array, second: Uint8Array): boolean;
/**
 * Trim prefix from string
 * @param str
 * @param prefix
 * @returns
 */
declare function trimPrefix(str: string, prefix: string): string;
/**
 * Concat hex strings
 * @param hexStrings
 * @returns
 */
declare function concatHexStrings(hexStrings: string[]): string;
/**
 * Parse input arguments
 * https://github.com/zkcrossteam/g1024/blob/916c489fefa65ce8d4ee1a387f2bd4a3dcca8337/src/data/image.ts#L95
 * @param raw
 * @returns
 */
declare function parseArgs(raw: string[]): any[];
/**
 * Get target network
 * @param inputtedNetworkName
 * @returns
 */
declare function getTargetNetwork(inputtedNetworkName: string): {
    name: string;
    label: string;
    value: number;
    expectedEth: number;
    hex: string;
} | {
    name: string;
    label: string;
    value: number;
    expectedEth?: undefined;
    hex?: undefined;
} | undefined;
/**
 * normalize DSP params
 * @param paramNames
 * @param paramKeyValue
 * @returns
 */
declare function dspParamsNormalize(paramNames?: string[], paramKeyValue?: Record<string, any>): {};
/**
 * Check if value is a number
 * @param value
 * @returns
 */
declare function isNumber(value: any): boolean;
interface NetworksConfig {
    mainnet?: any;
    sepolia?: any;
    goerli?: any;
}
declare function loadConfigByNetwork(yaml: Partial<ZkGraphYaml>, networksConfig: NetworksConfig, isDataSource: boolean): any;

declare const utils_areEqualArrays: typeof areEqualArrays;
declare const utils_concatHexStrings: typeof concatHexStrings;
declare const utils_dspParamsNormalize: typeof dspParamsNormalize;
declare const utils_fromHexString: typeof fromHexString;
declare const utils_getTargetNetwork: typeof getTargetNetwork;
declare const utils_isNumber: typeof isNumber;
declare const utils_loadConfigByNetwork: typeof loadConfigByNetwork;
declare const utils_parseArgs: typeof parseArgs;
declare const utils_toHexString: typeof toHexString;
declare const utils_toHexStringBytes32Reverse: typeof toHexStringBytes32Reverse;
declare const utils_trimPrefix: typeof trimPrefix;
declare namespace utils {
  export { utils_areEqualArrays as areEqualArrays, utils_concatHexStrings as concatHexStrings, utils_dspParamsNormalize as dspParamsNormalize, utils_fromHexString as fromHexString, utils_getTargetNetwork as getTargetNetwork, utils_isNumber as isNumber, utils_loadConfigByNetwork as loadConfigByNetwork, utils_parseArgs as parseArgs, utils_toHexString as toHexString, utils_toHexStringBytes32Reverse as toHexStringBytes32Reverse, utils_trimPrefix as trimPrefix };
}

declare const networks: ({
    name: string;
    label: string;
    value: number;
    expectedEth: number;
    hex: string;
} | {
    name: string;
    label: string;
    value: number;
    expectedEth?: undefined;
    hex?: undefined;
})[];
declare const AggregatorVerifierABI: {
    contractName: string;
    abi: ({
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        name?: undefined;
        outputs?: undefined;
        constant?: undefined;
    } | {
        inputs: {
            internalType: string;
            name: string;
            type: string;
        }[];
        name: string;
        outputs: never[];
        stateMutability: string;
        type: string;
        constant: boolean;
    })[];
};
declare const graph_abi: ({
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
    name?: undefined;
    outputs?: undefined;
} | {
    anonymous: boolean;
    inputs: {
        indexed: boolean;
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    type: string;
    stateMutability?: undefined;
    outputs?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    anonymous?: undefined;
})[];
declare const addressFactory: {
    mainnet: string;
    sepolia: string;
    goerli: string;
};
declare const abiFactory: string[];
declare const AggregatorVerifierAddress: {
    mainnet: string;
    sepolia: string;
    goerli: string;
};
declare const AddressZero = "0x0000000000000000000000000000000000000000";

declare const constants_AddressZero: typeof AddressZero;
declare const constants_AggregatorVerifierABI: typeof AggregatorVerifierABI;
declare const constants_AggregatorVerifierAddress: typeof AggregatorVerifierAddress;
declare const constants_abiFactory: typeof abiFactory;
declare const constants_addressFactory: typeof addressFactory;
declare const constants_graph_abi: typeof graph_abi;
declare const constants_networks: typeof networks;
declare namespace constants {
  export { constants_AddressZero as AddressZero, constants_AggregatorVerifierABI as AggregatorVerifierABI, constants_AggregatorVerifierAddress as AggregatorVerifierAddress, constants_abiFactory as abiFactory, constants_addressFactory as addressFactory, constants_graph_abi as graph_abi, constants_networks as networks };
}

export { DataPrep, DataSourcePlugin, index as ETHDSP, error as Error, type EthereumDSPExecParams, type EthereumDSPPrepareParams, type EthereumDSPProveParams, EthereumDataPrep, EthereumDataSourcePlugin, EthereumLocalDataSourcePlugin, EthereumOffchainDP, type EthereumOffchainDPDataPrep, EthereumOffchainDSP, type EthereumOffchainDSPExecParams, type EthereumOffchainDSPPrepareParams, type EthereumOffchainDSPProveParams, Input, TaskDispatch, type ZkGraphExecutable, ZkGraphYaml, constants, deposit, dspHub, execute, executeOnDataPrep, executeOnInputs, getBlockByNumber, getImageCommitment, getRawReceipts, getVerifyProofParamsByFile, getVerifyProofParamsByTaskID, hasDebugOnlyFunc, instantiateWasm, prove, proveInputGen, proveInputGenOnDataPrep, proveMock, publish, publishByImgCmt, setup, upload, utils, verify, verifyProof, waitProve, waitSetup, waitTaskStatus, zkwasm_deploy, zkwasm_imagedetails, zkwasm_prove, zkwasm_setup };
