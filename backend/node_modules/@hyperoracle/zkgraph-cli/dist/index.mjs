import cac from 'cac';
import { execSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import to from 'await-to-js';
import FormData from 'form-data';
import axios from 'axios';
import * as zkgapi from '@hyperoracle/zkgraph-api';
import { dspHub, TaskDispatch, zkwasm_imagedetails, waitSetup, upload as upload$1, ZkGraphYaml, getVerifyProofParamsByTaskID, verify as verify$1, Error as Error$1 } from '@hyperoracle/zkgraph-api';
import colors from 'picocolors';
import { Md5 } from 'ts-md5';
import ethres, { ethers, providers } from 'ethers';
import prompts from 'prompts';
import axiosRetry from 'axios-retry';
import api from 'api';
import { createConfigLoader } from 'unconfig';
import { init } from 'create-zkgraph';

const version = "1.0.0";

function fromHexString(hexString) {
  hexString = hexString.startsWith("0x") ? hexString.slice(2) : hexString;
  hexString = hexString.length % 2 ? `0${hexString}` : hexString;
  return Uint8Array.from(Buffer.from(hexString, "hex"));
}
function toHexString(uint8array) {
  return Buffer.from(uint8array).toString("hex");
}
const randomUniqueKey = (length = 6) => {
  const chars = "abcdefghijklmnopqrstuvwxyz1234567890";
  const maxPos = chars.length;
  let key = "";
  for (let i = 0; i < length; i++)
    key += chars.charAt(Math.floor(Math.random() * maxPos));
  return key;
};
function convertToMd5(value) {
  const md5 = new Md5();
  md5.appendByteArray(value);
  const hash = md5.end();
  if (!hash)
    return "";
  return hash.toString();
}

const LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
function createLogger(level = "info", prefix = "[zkGraph]") {
  const thresh = LogLevels[level];
  const timeFormatter = new Intl.DateTimeFormat(void 0, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  });
  function output(type, msg) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      const format = () => {
        const tag = type === "info" ? colors.cyan(colors.bold(prefix)) : type === "warn" ? colors.yellow(colors.bold(prefix)) : colors.red(colors.bold(prefix));
        return `${colors.dim(timeFormatter.format( new Date()))} ${tag} ${msg}`;
      };
      console[method](format());
    }
  }
  const logger2 = {
    info(msg) {
      output("info", msg);
    },
    warn(msg) {
      output("warn", msg);
    },
    error(msg) {
      output("error", msg);
    }
  };
  return logger2;
}
let logger = createLogger();
function setLogger(newLogger) {
  logger = newLogger;
}

function logDivider() {
  const line = "=".repeat(process.stdout.columns);
  console.log(line);
}

const DEFAULT_CONFIG = {
  JsonRpcProviderUrl: {
    mainnet: "https://rpc.ankr.com/eth",
    sepolia: "https://rpc.ankr.com/eth_sepolia",
    goerli: ""
  },
  UserPrivateKey: "",
  ZkwasmProviderUrl: "https://rpc.zkwasmhub.com:8090",
  CompilerServerEndpoint: "http://compiler.hyperoracle.io/compile",
  PinataEndpoint: "https://api.pinata.cloud/pinning/pinFileToIPFS",
  PinataJWT: "",
  WasmBinPath: "[root]/build/zkgraph_full.wasm",
  LocalWasmBinPath: "[root]/build/zkgraph_local.wasm",
  YamlPath: "[root]/src/zkgraph.yaml",
  MappingPath: "[root]/src/mapping.ts",
  OutputProofFilePath: "[root]/build/proof_[taskId].txt",
  logger: {
    level: "info"
  }
};
const TAGS = {
  root: process.cwd()
};
const COMPILE_TEMP_ENTRY_FILE_NAME_TEMPLATE = "entry_[salt].[env].ts";
const COMPILE_CODEGEN = (libDSPName, mappingFileName, handleFuncName) => `
import { zkmain_lib, asmain_lib, registerHandle } from "@hyperoracle/zkgraph-lib/dsp/${libDSPName}"
import { ${handleFuncName} } from "./${mappingFileName}"

declare function __call_as_start(): void;

export function zkmain(): void {
  __call_as_start();
  registerHandle(${handleFuncName})
  return zkmain_lib()
}

export function asmain(): Uint8Array {
  __call_as_start();
  registerHandle(${handleFuncName})
  return asmain_lib()
}
function abort(a: usize, b: usize, c: u32, d: u32): void {}
`;
const NETWORKS = [
  {
    name: "Sepolia",
    label: "Sepolia",
    value: 11155111,
    expectedEth: 2e-3,
    hex: "0xaa36a7"
  },
  {
    name: "Goerli",
    label: "Goerli",
    value: 5,
    expectedEth: 0.5,
    hex: "0x5"
  },
  {
    name: "Mainnet",
    label: "Mainnet",
    value: 1
  }
];
const TdConfig = {
  fee: "0.005",
  contract: "0x25AA9Ec3CA462f5AEA7fbd83A207E29Df4691380",
  queryrApi: "https://zkwasm.hyperoracle.io/td",
  providerUrl: "https://ethereum-sepolia.publicnode.com"
};
const DspStaticParamsMap = {
  prove: "proveParams",
  exec: "execParams"
};

function getTargetNetwork(inputtedNetworkName) {
  const validNetworkNames = NETWORKS.map((net) => net.name.toLowerCase());
  if (!validNetworkNames.includes(inputtedNetworkName.toLowerCase())) {
    console.log(`[-] NETWORK NAME "${inputtedNetworkName}" IS INVALID.`, "\n");
    console.log(`[*] Valid networks: ${validNetworkNames.join(", ")}.`, "\n");
    logDivider();
    process.exit(1);
  }
  const targetNetwork = NETWORKS.find(
    (net) => net.name.toLowerCase() === inputtedNetworkName.toLowerCase()
  );
  return targetNetwork;
}
async function validateProvider(ethersProvider) {
  try {
    await ethersProvider.detectNetwork();
    Promise.resolve();
  } catch (err) {
    if (err.code === "NETWORK_ERROR")
      Promise.reject(new Error("[-] could not detect network, please provide a valid provider in config file"));
    else
      Promise.reject(err);
  }
}

function loadJsonRpcProviderUrl(yaml, configJsonRpcProviderUrl, isDataSource) {
  let network;
  if (isDataSource)
    network = yaml.dataSources?.[0].network;
  else
    network = yaml.dataDestinations?.[0].network;
  if (!network) {
    logger.warn(
      `[-] NETWORK OF "${isDataSource ? "DATASOURCE" : "DATADESTINATION"}" IS NOT DEFINED IN YAML.`
    );
    return void 0;
  }
  const targetNetwork = getTargetNetwork(network)?.name.toLowerCase();
  let JsonRpcProviderUrl = "";
  if (targetNetwork) {
    JsonRpcProviderUrl = configJsonRpcProviderUrl ? configJsonRpcProviderUrl[targetNetwork] : void 0;
  }
  if (!JsonRpcProviderUrl) {
    logger.warn(
      `[-] JSON RPC PROVIDER URL FOR NETWORK "${network}" IS NOT DEFINED IN CONFIG.JS.`
    );
    logDivider();
    return void 0;
  }
  return JsonRpcProviderUrl;
}

async function codegen(mappingRoot, filename, content) {
  return new Promise((resolve, reject) => {
    try {
      const filepath = path.join(mappingRoot, filename);
      fs.writeFileSync(filepath, content, "utf-8");
      resolve(filename);
    } catch (error) {
      reject(error);
    }
  });
}

function createOnNonexist(filePath) {
  const directoryPath = path.dirname(filePath);
  if (!fs.existsSync(directoryPath))
    fs.mkdirSync(directoryPath, { recursive: true });
}

function getDspHubParams() {
  const hub = dspHub.hub;
  return generateDspHubParamsMap(hub);
}
const DoNotIncludeParams = ["jsonRpcUrl", "provider"];
function generateDspHubParamsMap(hub) {
  const dspParamsMap = {};
  for (const dspName of hub.keys()) {
    if (dspName.includes(":local"))
      continue;
    const dsp = hub.get(dspName);
    Reflect.set(dspParamsMap, dspName.replace(":full", ""), {
      execParams: dsp?.execParams.filter((item) => !DoNotIncludeParams.includes(item)),
      proveParams: dsp?.proveParams.filter((item) => !DoNotIncludeParams.includes(item))
    });
  }
  return dspParamsMap;
}
async function generateDspHubParams(dsp, params, command) {
  const dspProveParams = dsp[DspStaticParamsMap[command]].filter((param) => !DoNotIncludeParams.includes(param));
  if (params.length < dspProveParams.length)
    throw new Error(`Missing required args for command \`${command} ${dspProveParams.map((p) => `<${p}>`).join(" ")}\``);
  const realParams = {};
  dspProveParams.forEach((param, index) => {
    Reflect.set(realParams, param, params[index]);
  });
  return Promise.resolve(realParams);
}

function proveCLIHasModeOption() {
  const proveModeOptions = ["-i", "-t", "-p", "--inputgen", "--test", "--prove"];
  const argv = process.argv;
  if (!argv.length)
    return false;
  const command = argv[2];
  if (command === "prove") {
    for (let i = 3; i < argv.length; i++) {
      if (proveModeOptions.includes(argv[i]))
        return true;
    }
  }
  return false;
}
function generateCommandUsage() {
  const dspParams = getDspHubParams();
  function generateUsage(command) {
    const staticParams = DspStaticParamsMap[command];
    return Object.keys(dspParams).map((paramsName, index) => {
      const params = dspParams[paramsName][staticParams]?.map((param) => `<${param}>`).join(" ");
      return `${index > 0 ? "  " : ""}${`$ zkgraph ${command} ${params}`.trimStart().trimEnd()}`;
    }).join("\n");
  }
  return {
    proveUsage: generateUsage("prove"),
    execUsage: generateUsage("exec")
  };
}

const sdk = api("@pinata-cloud/v1.0#12ai2blmsggcsb");
async function checkPinataAuthentication(pinataJWT) {
  sdk.auth(pinataJWT);
  const [err, res] = await to(sdk.getDataTestauthentication());
  if (err)
    return false;
  return res.status === 200;
}

function parseTemplateTag(template, tags) {
  const value = template.replace(/\[(\w+)\]/g, (_, key) => {
    const isExistTag = Reflect.has(tags, key);
    const value2 = isExistTag ? tags[key] : `[${key}]`;
    return value2;
  });
  return value;
}

function checkExecExist(command) {
  try {
    execSync(command, { stdio: "ignore" });
    return true;
  } catch (error) {
    return false;
  }
}

const wasmStartName = "__as_start";
async function compile(options) {
  const {
    wasmPath,
    watPath,
    local
  } = options;
  if (!checkExecExist("asc") || !checkExecExist("npx asc")) {
    logger.error("[-] Please install assemblyscript in your package, you can run: npm install assemblyscript --save-dev");
    return;
  }
  const succ = local ? await compileLocal(options) : await compileServer(options);
  if (succ)
    logCompileResult(wasmPath, watPath);
}
async function compileLocal(options) {
  const {
    yamlPath,
    wasmPath,
    watPath,
    mappingPath,
    local
  } = options;
  if (!yamlPath) {
    logger.error("no yaml path provided");
    return false;
  }
  const yaml = zkgapi.ZkGraphYaml.fromYamlPath(yamlPath);
  if (!yaml) {
    logger.error("[-] ERROR: Failed to get yaml");
    return false;
  }
  const dsp = zkgapi.dspHub.getDSPByYaml(yaml, { isLocal: local });
  const libDSPName = dsp.getLibDSPName();
  const mappingFileName = yaml.mapping.file;
  const handleFuncName = yaml.mapping.handler;
  const dspKey = zkgapi.dspHub.toHubKeyByYaml(yaml, { isLocal: local });
  const srcDirPath = path.join(mappingPath, "..");
  const entryFilename = getEntryFilename(dspKey);
  const entryFilePath = await codegen(srcDirPath, entryFilename, COMPILE_CODEGEN(libDSPName, mappingFileName, handleFuncName));
  createOnNonexist(wasmPath);
  const [compileErr] = await to(ascCompile(path.join(srcDirPath, entryFilePath), wasmPath, watPath));
  if (compileErr) {
    logger.error(`[-] COMPILATION ERROR. ${compileErr.message}`);
    return false;
  }
  return true;
}
async function compileServer(options) {
  const {
    yamlPath,
    compilerServerEndpoint,
    wasmPath,
    watPath
    // mappingPath,
  } = options;
  if (!yamlPath) {
    logger.error("no yaml path provided");
    return false;
  }
  const tmpWasmPath = path.join(path.dirname(wasmPath), "/temp/inner_pre_pre.wasm");
  const originWasmPath = options.wasmPath;
  options.wasmPath = tmpWasmPath;
  const succ = await compileLocal(options);
  if (!succ)
    return false;
  options.wasmPath = originWasmPath;
  const data = new FormData();
  data.append("wasmFile", fs.createReadStream(tmpWasmPath));
  data.append("yamlFile", fs.createReadStream(yamlPath));
  const requestConfig = {
    method: "post",
    maxBodyLength: Infinity,
    url: compilerServerEndpoint,
    headers: {
      ...data.getHeaders()
    },
    data,
    timeout: 5e4
  };
  const [requestErr, response] = await to(axios.request(requestConfig));
  if (requestErr) {
    console.error(requestErr);
    logger.error(`[-] ERROR WHEN COMPILING. ${requestErr.message}`);
    return false;
  }
  if (!response) {
    logger.error("[-] ERROR WHEN COMPILING. invalid response");
    return false;
  }
  const wasmModuleHex = response.data.wasmModuleHex;
  const wasmWat = response.data.wasmWat;
  createOnNonexist(wasmPath);
  fs.writeFileSync(wasmPath, fromHexString(wasmModuleHex));
  createOnNonexist(watPath);
  fs.writeFileSync(watPath, wasmWat);
  return true;
}
async function ascCompile(entryFilePath, outputWasmPath, outputWatPath) {
  const abortPath = getAbortTsFilepath(entryFilePath);
  let commands = [
    "npx asc"
  ];
  const common = [
    `-o ${outputWasmPath}`,
    `-t ${outputWatPath}`,
    "-O",
    "--noAssert",
    "--disable",
    "bulk-memory",
    "--disable",
    "mutable-globals",
    "--exportRuntime",
    "--exportStart",
    wasmStartName,
    "--memoryBase",
    "70000",
    "--runtime stub"
  ];
  commands = commands.concat([
    entryFilePath,
    "--use",
    `abort=${abortPath}`
  ]);
  commands = commands.concat(common);
  return await execAndRmSync(commands.join(" "), entryFilePath);
}
function logCompileResult(wasmPath, watPath) {
  const compiledFileContent = fs.readFileSync(watPath, "utf-8");
  const compiledFileLineCount = compiledFileContent.split("\n").length;
  logger.info(`[*]${compiledFileLineCount}${compiledFileLineCount > 1 ? " lines" : " line"} in ${watPath}`);
  logger.info(`[+] Output written to \`${path.dirname(wasmPath)}\` folder.`);
  logger.info("[+] COMPILATION SUCCESS!\n");
}
async function execAndRmSync(command, filepath) {
  return new Promise((resolve, reject) => {
    try {
      execSync(command);
      fs.rmSync(filepath);
      resolve();
    } catch (error) {
      reject(error);
    }
  });
}
function getEntryFilename(env) {
  return parseTemplateTag(COMPILE_TEMP_ENTRY_FILE_NAME_TEMPLATE, {
    env,
    salt: randomUniqueKey(10)
  });
}
function getAbortTsFilepath(innerTsFilePath) {
  return `${innerTsFilePath.replace(process.cwd(), "").substring(1).replace(".ts", "")}/abort`.replaceAll("\\", "/");
}

async function exec(options) {
  const { yamlPath, jsonRpcProviderUrl, wasmPath, local, params = [] } = options;
  const zkgraphYaml = zkgapi.ZkGraphYaml.fromYamlPath(yamlPath);
  if (!zkgraphYaml) {
    logger.error("[-] ERROR: Failed to get yaml");
    return;
  }
  const dsp = zkgapi.dspHub.getDSPByYaml(zkgraphYaml, { isLocal: local });
  if (!dsp) {
    logger.error("[-] ERROR: Failed to get DSP");
    return;
  }
  const [generateErr, realParams] = await to(generateDspHubParams(dsp, params, "exec"));
  if (generateErr) {
    console.log(generateErr.message);
    return;
  }
  if (realParams?.blockId)
    logger.info(`[*] Run zkgraph on block ${realParams?.blockId}`);
  const jsonRpcUrl = loadJsonRpcProviderUrl(zkgraphYaml, jsonRpcProviderUrl, true);
  const provider = new ethres.providers.JsonRpcProvider(jsonRpcUrl);
  const wasm = fs.readFileSync(wasmPath);
  const wasmUint8Array = new Uint8Array(wasm);
  const execParams = dsp.toExecParams(
    {
      provider,
      ...realParams
    }
  );
  const zkgraphExecutable = {
    wasmUint8Array,
    zkgraphYaml
  };
  const state = await zkgapi.execute(
    zkgraphExecutable,
    execParams,
    local,
    true
  );
  logger.info(`[+] ZKGRAPH STATE OUTPUT: ${toHexString(state)}
`);
  return state;
}

axiosRetry(axios, {
  retries: 3,
  retryDelay: (retryCount) => {
    return retryCount * 1e3;
  }
});
function getDispatcher(userPrivateKey) {
  const provider = new ethers.providers.JsonRpcProvider(TdConfig.providerUrl);
  const signer = new ethers.Wallet(userPrivateKey, provider);
  const feeInWei = ethers.utils.parseEther(TdConfig.fee);
  const dispatcher = new TaskDispatch(TdConfig.queryrApi, TdConfig.contract, feeInWei, provider, signer);
  return dispatcher;
}
async function uploadWasmToTd(wasmPath) {
  const data = new FormData();
  data.append("file", fs.createReadStream(wasmPath));
  const requestConfig = {
    method: "post",
    maxBodyLength: Infinity,
    url: `${TdConfig.queryrApi}/upload`,
    headers: {
      ...data.getHeaders()
    },
    data
  };
  const response = await axios.request(requestConfig).catch((error) => {
    throw error;
  });
  return response.data.filename;
}

async function setup(options) {
  const { wasmPath, circuitSize, zkWasmProviderUrl, userPrivateKey } = options;
  logger.info(">> SET UP");
  if (!userPrivateKey) {
    logger.error("[-] USER PRIVATE KEY IS NOT DEFINED.");
    return;
  }
  const md5 = await uploadWasmToTd(wasmPath);
  logger.info(`[*] IMAGE MD5: ${md5}`);
  const deatails = await zkwasm_imagedetails(zkWasmProviderUrl, md5);
  if (deatails[0]?.data.result[0] !== null) {
    logger.error("[*] IMAGE ALREADY EXISTS");
    return;
  }
  const response = await prompts({
    type: "confirm",
    name: "value",
    message: `You are going to publish a Setup request to the Sepolia testnet, which would require ${TdConfig.fee} SepoliaETH. Proceed?`,
    initial: true
  }, {
    onCancel: () => {
      logger.error("Operation cancelled");
    }
  });
  if (response.value === false) {
    logger.error("Operation cancelled");
    return;
  }
  const dispatcher = getDispatcher(userPrivateKey);
  const tx = await dispatcher.setup(md5, circuitSize);
  const txhash = tx.hash;
  logger.info(
    `[+] Setup Request Transaction Sent: ${txhash}, Waiting for Confirmation`
  );
  await tx.wait();
  logger.info("[+] Transaction Confirmed. Creating Setup Task");
  const data = await dispatcher.queryTask(txhash);
  const taskId = data.task.id;
  if (!taskId) {
    logger.error("[+] SETUP TASK FAILED. \n");
    return;
  }
  logger.info(`[+] SETUP TASK STARTED. TASK ID: ${taskId}`);
  const result = await waitSetup(zkWasmProviderUrl, taskId, true);
  return result;
}

async function prove(options) {
  const {
    params = [],
    inputgen,
    test,
    prove: prove2,
    local,
    wasmPath,
    yamlPath,
    jsonRpcProviderUrl,
    zkWasmProviderUrl,
    userPrivateKey,
    outputProofFilePath
  } = options;
  const yaml = zkgapi.ZkGraphYaml.fromYamlPath(yamlPath);
  if (!yaml) {
    logger.error("[-] ERROR: Failed to get yaml");
    return;
  }
  const dsp = zkgapi.dspHub.getDSPByYaml(yaml, { isLocal: local });
  if (!dsp) {
    logger.error("[-] ERROR: Failed to get DSP");
    return;
  }
  const [generateErr, realParams] = await to(generateDspHubParams(dsp, params, "prove"));
  if (generateErr) {
    console.log(generateErr.message);
    return;
  }
  switch (inputgen || test || prove2) {
    case options.inputgen === true:
      logger.info(">> PROVE: INPUT GENERATION MODE");
      break;
    case options.test === true:
      logger.info(">> PROVE: PRETEST MODE");
      logger.warn(">> PROVE: TEST MODE DOESN'T OUTPUT PROOF FILE");
      break;
    case options.prove === true:
      logger.info(">> PROVE: PROVE MODE");
      logger.warn(">> PROVE: REQUIRE FINISH SETUP FIRST");
      break;
  }
  const jsonRpcUrl = loadJsonRpcProviderUrl(yaml, jsonRpcProviderUrl, true);
  const provider = new providers.JsonRpcProvider(jsonRpcUrl);
  const [validateErr] = await to(validateProvider(provider));
  if (validateErr) {
    logger.error(`[-] PROVIDER VALIDATION ERROR. ${validateErr.message}`);
    return;
  }
  const wasm = fs.readFileSync(wasmPath);
  const wasmUint8Array = new Uint8Array(wasm);
  const md5 = convertToMd5(wasmUint8Array).toUpperCase();
  const proveParams = dsp.toProveParams(
    {
      provider,
      ...realParams
    }
  );
  const zkgraphExecutable = {
    wasmUint8Array,
    zkgraphYaml: yaml
  };
  const [privateInputStr, publicInputStr] = await zkgapi.proveInputGen(
    zkgraphExecutable,
    proveParams,
    local,
    true
  );
  if (inputgen) {
    logger.info(`[+] PRIVATE INPUT FOR ZKWASM:
${privateInputStr}`);
    logger.info(`[+] PUBLIC INPUT FOR ZKWASM:
${publicInputStr}`);
  } else if (test) {
    await testMode(wasmUint8Array, privateInputStr, publicInputStr);
  } else if (prove2) {
    await proveMode(userPrivateKey, md5, privateInputStr, publicInputStr, zkWasmProviderUrl, outputProofFilePath);
  }
}
async function testMode(wasmUint8Array, privateInputStr, publicInputStr) {
  const zkgraphExecutable = {
    wasmUint8Array,
    zkgraphYaml: null
  };
  const [mockErr, mockSuccess] = await to(zkgapi.proveMock(
    zkgraphExecutable,
    privateInputStr,
    publicInputStr
  ));
  if (mockErr) {
    logger.error(`[-] ZKWASM MOCK EXECUTION ERROR: ${mockErr.message}`);
    return;
  }
  if (mockSuccess) {
    logger.info("[+] ZKWASM MOCK EXECUTION SUCCESS!");
    if (zkgapi.hasDebugOnlyFunc)
      logger.warn("[+] PLEASE REMOVE DEBUG FUNCTION (e.g. console.log) BEFORE PROVE MODE");
    else
      logger.warn("[+] READY FOR PROVE MODE: npx zkgraph prove <block id> <expected state> --prove");
  } else {
    logger.error("[-] ZKWASM MOCK EXECUTION FAILED");
  }
}
async function proveMode(userPrivateKey, md5, privateInputStr, publicInputStr, zkWasmProviderUrl, outputProofFilePath) {
  const response = await prompts({
    type: "confirm",
    name: "value",
    message: `You are going to publish a Prove request to the Sepolia testnet, which would require ${TdConfig.fee} SepoliaETH. Proceed?`,
    initial: true
  }, {
    onCancel: () => {
      logger.error("Operation cancelled");
    }
  });
  if (response.value === false) {
    logger.error("Operation cancelled");
    return;
  }
  const dispatcher = getDispatcher(userPrivateKey);
  const tx = await dispatcher.prove(md5, privateInputStr, publicInputStr);
  const txhash = tx.hash;
  logger.info(
    `[+] Prove Request Transaction Sent: ${txhash}, Waiting for Confirmation`
  );
  await tx.wait();
  logger.info("[+] Transaction Confirmed. Creating Prove Task");
  const [queryTaskErr, data] = await to(dispatcher.queryTask(txhash));
  if (queryTaskErr) {
    if (queryTaskErr instanceof zkgapi.Error.TDNoTaskFound) {
      logger.error("[-] PLEASE REQUIRE FINISH SETUP FIRST.");
      return;
    } else {
      throw queryTaskErr;
    }
  }
  const taskId = data?.task?.id;
  if (!taskId) {
    logger.error("[+] PROVE TASK FAILED. \n");
    return;
  }
  logger.info(`[+] PROVE TASK STARTED. TASK ID: ${taskId}`);
  logger.info("[+] WAITING FOR PROVE RESULT. ABOUT 3 TO 5 MINUTED");
  const result = await zkgapi.waitProve(zkWasmProviderUrl, taskId, true);
  if (result.instances === null && result.batch_instances === null && result.proof === null && result.aux === null) {
    logger.warn("[-] PROOF NOT FOUND");
    return;
  }
  const outputProofFile = parseTemplateTag(outputProofFilePath, {
    ...TAGS,
    taskId: result.taskId || ""
  });
  logger.info(`[+] Proof written to ${outputProofFile}.
`);
  fs.writeFileSync(
    outputProofFile,
    `Instances:
${result.instances}

Batched Instances:
${result.batch_instances}

Proof transcripts:
${result.proof}

Aux data:
${result.aux}
`
  );
}

async function upload(options) {
  logger.info(">> UPLOAD");
  const { wasmPath, yamlPath, mappingPath, pinataEndpoint, pinataJWT } = options;
  if (!await checkPinataAuthentication(pinataJWT)) {
    logger.error("[-] PINATA AUTHENTICATION FAILED.");
    return;
  }
  const { isUploadSuccess, response, errorMessage } = await upload$1(
    mappingPath,
    wasmPath,
    yamlPath,
    // userAddress,
    pinataEndpoint,
    pinataJWT
    // true,
  );
  if (isUploadSuccess) {
    logger.info("[+] IPFS UPLOAD SUCCESS!");
    logger.info(`[+] IPFS HASH: ${response.data.IpfsHash}`);
    if (response.data.isDuplicate)
      logger.info("[*] Please note that this upload is duplicated.");
  } else {
    logger.info("[-] IPFS UPLOAD FAILED.");
    logger.info(`[-] ${errorMessage}`);
  }
  return isUploadSuccess;
}

async function verify(options) {
  logger.info(">> VERIFY PROOF ONCHAIN");
  const { yamlPath, taskId, zkWasmProviderUrl, jsonRpcProviderUrl } = options;
  const zkgraphYaml = ZkGraphYaml.fromYamlPath(yamlPath);
  if (!zkgraphYaml) {
    logger.error("[-] ERROR: Failed to get yaml");
    return;
  }
  const jsonRpcUrl = loadJsonRpcProviderUrl(zkgraphYaml, jsonRpcProviderUrl, false);
  const proofParams = await getVerifyProofParamsByTaskID(taskId, zkWasmProviderUrl);
  const verifyResult = await verify$1(
    {
      zkgraphYaml,
      wasmUint8Array: null
    },
    proofParams,
    jsonRpcUrl || ""
  ).catch((error) => {
    if (error instanceof Error$1.ProveTaskNotReady)
      logger.error(`>> PROOF IS NOT READY. ${error.message}`);
  });
  logDivider();
  if (verifyResult)
    logger.info(">> VERIFY PROOF ONCHAIN SUCCESS");
  else
    logger.error(">> VERIFY PROOF ONCHAIN FAILED");
  return verifyResult;
}

async function publish(options) {
  const { ipfsHash, jsonRpcProviderUrl, userPrivateKey, bountyRewardPerTrigger, yamlPath, wasmPath, zkWasmProviderUrl } = options;
  logger.info(">> PUBLISH ZKGRAPH");
  if (isNaN(bountyRewardPerTrigger)) {
    logger.warn("[-] BOUNTY REWARD IS NOT A VALID NUMBER.");
    logDivider();
  }
  const newBountyRewardPerTrigger = bountyRewardPerTrigger * 10 ** 9;
  const zkgraphYaml = zkgapi.ZkGraphYaml.fromYamlPath(yamlPath);
  if (!zkgraphYaml) {
    logger.error("[-] ERROR: Failed to get yaml");
    return;
  }
  const JsonRpcProviderUrl = loadJsonRpcProviderUrl(zkgraphYaml, jsonRpcProviderUrl, false);
  const provider = new ethers.providers.JsonRpcProvider(JsonRpcProviderUrl);
  const signer = new ethers.Wallet(userPrivateKey, provider);
  const wasm = fs.readFileSync(wasmPath);
  const wasmUint8Array = new Uint8Array(wasm);
  const [err, publishTxHash] = await to(zkgapi.publish(
    { wasmUint8Array, zkgraphYaml },
    zkWasmProviderUrl,
    provider,
    ipfsHash,
    newBountyRewardPerTrigger,
    signer,
    true
  ));
  if (err) {
    if (err instanceof zkgapi.Error.GraphAlreadyExist) {
      logger.error(`[-] PUBLISH FAILED. ${err.message}`);
      return publishTxHash;
    } else {
      throw err;
    }
  }
  if (publishTxHash === "")
    logger.error("[-] PUBLISH FAILED.");
  else
    logger.info(`[*] PUBLISH TX HASH: ${publishTxHash}`);
  return publishTxHash;
}

function defineConfig(config) {
  return config;
}
async function loadConfigFromFile(configFile, configRoot = process.cwd()) {
  async function rewrite(config) {
    const resolved = await (typeof config === "function" ? config() : config);
    return resolved;
  }
  const loader = await createConfigLoader({
    cwd: configRoot,
    sources: [configFile ? {
      files: configFile || "",
      extensions: [],
      rewrite
    } : {
      files: "zkgraph.config",
      extensions: ["ts", "mts", "cts", "js", "mjs", "cjs", "json"],
      rewrite
    }],
    defaults: DEFAULT_CONFIG
  });
  const result = await loader.load();
  return result.config;
}
async function getConfig(configFile, configRoot) {
  const userConfig = await loadConfigFromFile(configFile, configRoot);
  userConfig.WasmBinPath = parseTemplateTag(userConfig.WasmBinPath || "", TAGS);
  userConfig.LocalWasmBinPath = parseTemplateTag(userConfig.LocalWasmBinPath || "", TAGS);
  userConfig.YamlPath = parseTemplateTag(userConfig.YamlPath || "", TAGS);
  userConfig.MappingPath = parseTemplateTag(userConfig.MappingPath || "", TAGS);
  return userConfig;
}

function create(targetDir, template) {
  init(targetDir, template);
}

async function deposit(options) {
  const { jsonRpcProviderUrl, deployedContractAddress, depositAmount, userPrivateKey, yamlPath } = options;
  const zkgraphYaml = zkgapi.ZkGraphYaml.fromYamlPath(yamlPath);
  if (!zkgraphYaml) {
    logger.error("[-] ERROR: Failed to get yaml");
    return;
  }
  const jsonRpcUrl = loadJsonRpcProviderUrl(zkgraphYaml, jsonRpcProviderUrl, true);
  if (!jsonRpcUrl) {
    logger.error("[-] ERROR: Failed to get jsonRpcUrl");
    return;
  }
  const provider = new ethers.providers.JsonRpcProvider(jsonRpcUrl);
  const signer = new ethers.Wallet(userPrivateKey, provider);
  const transactionHash = zkgapi.deposit(
    provider,
    signer,
    deployedContractAddress,
    depositAmount,
    true
  );
  if (transactionHash)
    logger.info(`[*] DEPOSIT SUCCESS. TRANSACTION HASH: ${transactionHash}`);
  else
    logger.error(`[-] DEPOSIT FAILED. TRANSACTION HASH: ${transactionHash}`);
}

async function run() {
  try {
    const cli = cac("zkgraph");
    const config = await getConfig();
    setLogger(createLogger(config.logger?.level || "info"));
    const { proveUsage, execUsage } = generateCommandUsage();
    cli.command("compile", "Compile for Full Image (Link Compiled with Compiler Server)").option("--local", "Compile for Local Image").option("--yaml-path <path>", "Path to yaml file").option("--mapping-path <path>", "Path to mapping file").example("zkgraph compile").action((options) => {
      const { local = false, yamlPath = "", mappingPath = "" } = options;
      const wasmPath = local ? config.LocalWasmBinPath : config.WasmBinPath;
      compile({
        local,
        yamlPath: yamlPath || config.YamlPath,
        compilerServerEndpoint: config.CompilerServerEndpoint,
        wasmPath,
        watPath: wasmPath.replace(/\.wasm/, ".wat"),
        mappingPath: mappingPath || config.MappingPath
      });
    });
    cli.command("exec [...params]", "Execute Full Image").option("--local", "Execute Local Image").example("zkgraph exec 0000000").action((params, options) => {
      const { local = false } = options;
      const wasmPath = local ? config.LocalWasmBinPath : config.WasmBinPath;
      exec({
        local,
        wasmPath,
        yamlPath: config.YamlPath,
        jsonRpcProviderUrl: config.JsonRpcProviderUrl,
        params
      });
    }).usage(`[...params]

Usage cases:
  ${execUsage}`);
    cli.command("setup", "Set Up Full Image").option("--local", "Set Up Local Image").option("-k, --circuit-size <size>", "Circuit size (k in 2^k) of image").example("zkgraph setup -k 20").action((options) => {
      const { circuitSize = "", local = false } = options;
      const wasmPath = local ? config.LocalWasmBinPath : config.WasmBinPath;
      const size = !circuitSize || circuitSize === 0 ? local ? 20 : 22 : Number(circuitSize);
      setup({
        circuitSize: size,
        wasmPath,
        userPrivateKey: config.UserPrivateKey,
        zkWasmProviderUrl: config.ZkwasmProviderUrl
      });
    });
    const proveCLI = cli.command("prove [...params]", "Prove Full Image").option("--local", "Prove Local Image").option("-i, --inputgen", "Run in input generation Mode").option("-t, --test", "Run in test Mode").option("-p, --prove", "Run in prove Mode").example("zkgraph prove 2279547 a60ecf32309539dd84f27a9563754dca818b815e -t").example("zkgraph prove 2279547 a60ecf32309539dd84f27a9563754dca818b815e -i").example("zkgraph prove 2279547 a60ecf32309539dd84f27a9563754dca818b815e -p").action((params, options) => {
      let { inputgen = false, test = false, prove: prove$1 = false, local = false } = options;
      const hasMode = proveCLIHasModeOption();
      if (!hasMode)
        test = true;
      if (!(inputgen || test || prove$1)) {
        logger.error("error: missing running mode (-i / -t / -p)\n");
        proveCLI.outputHelp();
        return;
      }
      const wasmPath = local ? config.LocalWasmBinPath : config.WasmBinPath;
      prove({
        params,
        inputgen,
        test,
        prove: prove$1,
        local,
        wasmPath,
        yamlPath: config.YamlPath,
        jsonRpcProviderUrl: config.JsonRpcProviderUrl,
        zkWasmProviderUrl: config.ZkwasmProviderUrl,
        userPrivateKey: config.UserPrivateKey,
        outputProofFilePath: config.OutputProofFilePath
      });
    }).usage(`[...params]

Usage cases:
  ${proveUsage}`);
    cli.command("upload", "Upload zkGraph (Code and Full Image)").option("--local", "Upload Local zkGraph (Code and Local Image)").example("zkgraph upload").action((options) => {
      const { local = false } = options;
      upload({
        local,
        wasmPath: local ? config.LocalWasmBinPath : config.WasmBinPath,
        yamlPath: config.YamlPath,
        pinataEndpoint: config.PinataEndpoint,
        pinataJWT: config.PinataJWT,
        mappingPath: config.MappingPath
        // userPrivateKey: config.UserPrivateKey,
      });
    });
    cli.command("verify <prove task id>", "Verify Proof Onchain").example("zkgraph verify 000000").action((taskId) => {
      verify({
        taskId,
        yamlPath: config.YamlPath,
        zkWasmProviderUrl: config.ZkwasmProviderUrl,
        jsonRpcProviderUrl: config.JsonRpcProviderUrl
      });
    });
    cli.command("publish <ipfs_hash> <bounty_reward_per_trigger>", "Publish and Register zkGraph Onchain").example("zkgraph publish 0x00000000000000000000000000000000 0x00000000000000000000000000000000 100").usage(`publish <ipfs_hash> <bounty_reward_per_trigger>

    ipfs_hash: by finishing upload get it
      `).action((ipfsHash, bountyRewardPerTrigger) => {
      publish({
        ipfsHash,
        bountyRewardPerTrigger,
        yamlPath: config.YamlPath,
        wasmPath: config.WasmBinPath,
        jsonRpcProviderUrl: config.JsonRpcProviderUrl,
        userPrivateKey: config.UserPrivateKey,
        zkWasmProviderUrl: config.ZkwasmProviderUrl
      });
    });
    cli.command("init <target directory>", "Init zkGraph template").alias("create").option("-t, --template <template>", "Use template").example("zkgraph init -t default").action((directory, options) => {
      create(directory, options.template);
    });
    cli.command("deposit <deployed contract address> <deposit amount>", "Publish and register zkGraph onchain.").example("zkgraph deposit 0x00000000000000000000000000000000 0.1").action((deployedContractAddress, depositAmount) => {
      deposit({
        jsonRpcProviderUrl: config.JsonRpcProviderUrl,
        deployedContractAddress,
        depositAmount,
        userPrivateKey: config.UserPrivateKey,
        yamlPath: config.YamlPath
      });
    });
    cli.help();
    cli.version(version);
    cli.parse();
  } catch (error) {
    errorHandler(error);
  }
}
function errorHandler(error) {
  console.error(error.message);
  return process.exit(1);
}

export { defineConfig, run };
